"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["node_modules_pnpm_viem_1_0_0_typescript_5_0_4_zod_3_21_4_node_modules_viem_dist_esm_ens_js"],{

/***/ "../../node_modules/.pnpm/@adraffy+ens-normalize@1.9.0/node_modules/@adraffy/ens-normalize/dist/index.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/@adraffy+ens-normalize@1.9.0/node_modules/@adraffy/ens-normalize/dist/index.js ***!
  \***************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ens_beautify\": function() { return /* binding */ ens_beautify; },\n/* harmony export */   \"ens_emoji\": function() { return /* binding */ ens_emoji; },\n/* harmony export */   \"ens_normalize\": function() { return /* binding */ ens_normalize; },\n/* harmony export */   \"ens_normalize_fragment\": function() { return /* binding */ ens_normalize_fragment; },\n/* harmony export */   \"ens_split\": function() { return /* binding */ ens_split; },\n/* harmony export */   \"ens_tokenize\": function() { return /* binding */ ens_tokenize; },\n/* harmony export */   \"is_combining_mark\": function() { return /* binding */ is_combining_mark; },\n/* harmony export */   \"nfc\": function() { return /* binding */ nfc; },\n/* harmony export */   \"nfd\": function() { return /* binding */ nfd; },\n/* harmony export */   \"safe_str_from_cps\": function() { return /* binding */ safe_str_from_cps; },\n/* harmony export */   \"should_escape\": function() { return /* binding */ should_escape; }\n/* harmony export */ });\nfunction decode_arithmetic(bytes) {\r\n\tlet pos = 0;\r\n\tfunction u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\r\n\t\r\n\t// decode the frequency table\r\n\tlet symbol_count = u16();\r\n\tlet total = 1;\r\n\tlet acc = [0, 1]; // first symbol has frequency 1\r\n\tfor (let i = 1; i < symbol_count; i++) {\r\n\t\tacc.push(total += u16());\r\n\t}\r\n\r\n\t// skip the sized-payload that the last 3 symbols index into\r\n\tlet skip = u16();\r\n\tlet pos_payload = pos;\r\n\tpos += skip;\r\n\r\n\tlet read_width = 0;\r\n\tlet read_buffer = 0; \r\n\tfunction read_bit() {\r\n\t\tif (read_width == 0) {\r\n\t\t\t// this will read beyond end of buffer\r\n\t\t\t// but (undefined|0) => zero pad\r\n\t\t\tread_buffer = (read_buffer << 8) | bytes[pos++];\r\n\t\t\tread_width = 8;\r\n\t\t}\r\n\t\treturn (read_buffer >> --read_width) & 1;\r\n\t}\r\n\r\n\tconst N = 31;\r\n\tconst FULL = 2**N;\r\n\tconst HALF = FULL >>> 1;\r\n\tconst QRTR = HALF >> 1;\r\n\tconst MASK = FULL - 1;\r\n\r\n\t// fill register\r\n\tlet register = 0;\r\n\tfor (let i = 0; i < N; i++) register = (register << 1) | read_bit();\r\n\r\n\tlet symbols = [];\r\n\tlet low = 0;\r\n\tlet range = FULL; // treat like a float\r\n\twhile (true) {\r\n\t\tlet value = Math.floor((((register - low + 1) * total) - 1) / range);\r\n\t\tlet start = 0;\r\n\t\tlet end = symbol_count;\r\n\t\twhile (end - start > 1) { // binary search\r\n\t\t\tlet mid = (start + end) >>> 1;\r\n\t\t\tif (value < acc[mid]) {\r\n\t\t\t\tend = mid;\r\n\t\t\t} else {\r\n\t\t\t\tstart = mid;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (start == 0) break; // first symbol is end mark\r\n\t\tsymbols.push(start);\r\n\t\tlet a = low + Math.floor(range * acc[start]   / total);\r\n\t\tlet b = low + Math.floor(range * acc[start+1] / total) - 1;\r\n\t\twhile (((a ^ b) & HALF) == 0) {\r\n\t\t\tregister = (register << 1) & MASK | read_bit();\r\n\t\t\ta = (a << 1) & MASK;\r\n\t\t\tb = (b << 1) & MASK | 1;\r\n\t\t}\r\n\t\twhile (a & ~b & QRTR) {\r\n\t\t\tregister = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\r\n\t\t\ta = (a << 1) ^ HALF;\r\n\t\t\tb = ((b ^ HALF) << 1) | HALF | 1;\r\n\t\t}\r\n\t\tlow = a;\r\n\t\trange = 1 + b - a;\r\n\t}\r\n\tlet offset = symbol_count - 4;\r\n\treturn symbols.map(x => { // index into payload\r\n\t\tswitch (x - offset) {\r\n\t\t\tcase 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\r\n\t\t\tcase 1: return offset + bytes[pos_payload++];\r\n\t\t\tdefault: return x - 1;\r\n\t\t}\r\n\t});\r\n}\t\r\n\r\n// returns an iterator which returns the next symbol\r\nfunction read_payload(v) {\r\n\tlet pos = 0;\r\n\treturn () => v[pos++];\r\n}\r\nfunction read_compressed_payload(s) {\r\n\treturn read_payload(decode_arithmetic(unsafe_atob(s)));\r\n}\r\n\r\n// unsafe in the sense:\r\n// expected well-formed Base64 w/o padding \r\nfunction unsafe_atob(s) {\r\n\tlet lookup = [];\r\n\t[...'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'].forEach((c, i) => lookup[c.charCodeAt(0)] = i);\r\n\tlet n = s.length;\r\n\tlet ret = new Uint8Array((6 * n) >> 3);\r\n\tfor (let i = 0, pos = 0, width = 0, carry = 0; i < n; i++) {\r\n\t\tcarry = (carry << 6) | lookup[s.charCodeAt(i)];\r\n\t\twidth += 6;\r\n\t\tif (width >= 8) {\r\n\t\t\tret[pos++] = (carry >> (width -= 8));\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\r\nfunction signed(i) { \r\n\treturn (i & 1) ? (~i >> 1) : (i >> 1);\r\n}\r\n\r\nfunction read_deltas(n, next) {\r\n\tlet v = Array(n);\r\n\tfor (let i = 0, x = 0; i < n; i++) v[i] = x += signed(next());\r\n\treturn v;\r\n}\r\n\r\n// [123][5] => [0 3] [1 1] [0 0]\r\nfunction read_sorted(next, prev = 0) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet x = next();\r\n\t\tlet n = next();\r\n\t\tif (!n) break;\r\n\t\tprev += x;\r\n\t\tfor (let i = 0; i < n; i++) {\r\n\t\t\tret.push(prev + i);\r\n\t\t}\r\n\t\tprev += n + 1;\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction read_sorted_arrays(next) {\r\n\treturn read_array_while(() => { \r\n\t\tlet v = read_sorted(next);\r\n\t\tif (v.length) return v;\r\n\t});\r\n}\r\n\r\n// returns map of x => ys\r\nfunction read_mapped(next) {\r\n\tlet ret = [];\r\n\twhile (true) {\r\n\t\tlet w = next();\r\n\t\tif (w == 0) break;\r\n\t\tret.push(read_linear_table(w, next));\r\n\t}\r\n\twhile (true) {\r\n\t\tlet w = next() - 1;\r\n\t\tif (w < 0) break;\r\n\t\tret.push(read_replacement_table(w, next));\r\n\t}\r\n\treturn ret.flat();\r\n}\r\n\r\n// read until next is falsy\r\n// return array of read values\r\nfunction read_array_while(next) {\r\n\tlet v = [];\r\n\twhile (true) {\r\n\t\tlet x = next(v.length);\r\n\t\tif (!x) break;\r\n\t\tv.push(x);\r\n\t}\r\n\treturn v;\r\n}\r\n\r\n// read w columns of length n\r\n// return as n rows of length w\r\nfunction read_transposed(n, w, next) {\r\n\tlet m = Array(n).fill().map(() => []);\r\n\tfor (let i = 0; i < w; i++) {\r\n\t\tread_deltas(n, next).forEach((x, j) => m[j].push(x));\r\n\t}\r\n\treturn m;\r\n}\r\n \r\n// returns [[x, ys], [x+dx, ys+dy], [x+2*dx, ys+2*dy], ...]\r\n// where dx/dy = steps, n = run size, w = length of y\r\nfunction read_linear_table(w, next) {\r\n\tlet dx = 1 + next();\r\n\tlet dy = next();\r\n\tlet vN = read_array_while(next);\r\n\tlet m = read_transposed(vN.length, 1+w, next);\r\n\treturn m.flatMap((v, i) => {\r\n\t\tlet [x, ...ys] = v;\r\n\t\treturn Array(vN[i]).fill().map((_, j) => {\r\n\t\t\tlet j_dy = j * dy;\r\n\t\t\treturn [x + j * dx, ys.map(y => y + j_dy)];\r\n\t\t});\r\n\t});\r\n}\r\n\r\n// return [[x, ys...], ...]\r\n// where w = length of y\r\nfunction read_replacement_table(w, next) { \r\n\tlet n = 1 + next();\r\n\tlet m = read_transposed(n, 1+w, next);\r\n\treturn m.map(v => [v[0], v.slice(1)]);\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r$1 = read_compressed_payload('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');\nconst FENCED = new Map([[8217,\"apostrophe\"],[8260,\"fraction slash\"],[12539,\"middle dot\"]]);\nconst NSM_MAX = 4;\n\nfunction hex_cp(cp) {\r\n\treturn cp.toString(16).toUpperCase().padStart(2, '0');\r\n}\r\n\r\nfunction quote_cp(cp) {\r\n\treturn `{${hex_cp(cp)}}`; // raffy convention: like \"\\u{X}\" w/o the \"\\u\"\r\n}\r\n\r\n/*\r\nexport function explode_cp(s) {\r\n\treturn [...s].map(c => c.codePointAt(0));\r\n}\r\n*/\r\nfunction explode_cp(s) { // this is about 2x faster\r\n\tlet cps = [];\r\n\tfor (let pos = 0, len = s.length; pos < len; ) {\r\n\t\tlet cp = s.codePointAt(pos);\r\n\t\tpos += cp < 0x10000 ? 1 : 2;\r\n\t\tcps.push(cp);\r\n\t}\r\n\treturn cps;\r\n}\r\n\r\nfunction str_from_cps(cps) {\r\n\tconst chunk = 4096;\r\n\tlet len = cps.length;\r\n\tif (len < chunk) return String.fromCodePoint(...cps);\r\n\tlet buf = [];\r\n\tfor (let i = 0; i < len; ) {\r\n\t\tbuf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));\r\n\t}\r\n\treturn buf.join('');\r\n}\r\n\r\nfunction compare_arrays(a, b) {\r\n\tlet n = a.length;\r\n\tlet c = n - b.length;\r\n\tfor (let i = 0; c == 0 && i < n; i++) c = a[i] - b[i];\r\n\treturn c;\r\n}\n\n// created 2023-02-21T09:18:13.549Z\nvar r = read_compressed_payload('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');\n\n// https://unicode.org/reports/tr15/\r\n\r\nfunction unpack_cc(packed) {\r\n\treturn (packed >> 24) & 0xFF;\r\n}\r\nfunction unpack_cp(packed) {\r\n\treturn packed & 0xFFFFFF;\r\n}\r\n\r\nconst SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map(x => [x, (i+1) << 24]))); // pre-shifted\r\nconst EXCLUSIONS = new Set(read_sorted(r));\r\nconst DECOMP = new Map();\r\nconst RECOMP = new Map();\r\nfor (let [cp, cps] of read_mapped(r)) {\r\n\tif (!EXCLUSIONS.has(cp) && cps.length == 2) {\r\n\t\tlet [a, b] = cps;\r\n\t\tlet bucket = RECOMP.get(a);\r\n\t\tif (!bucket) {\r\n\t\t\tbucket = new Map();\r\n\t\t\tRECOMP.set(a, bucket);\r\n\t\t}\r\n\t\tbucket.set(b, cp);\r\n\t}\r\n\tDECOMP.set(cp, cps.reverse()); // stored reversed\r\n}\r\n\r\n// algorithmic hangul\r\n// https://www.unicode.org/versions/Unicode15.0.0/ch03.pdf (page 144)\r\nconst S0 = 0xAC00;\r\nconst L0 = 0x1100;\r\nconst V0 = 0x1161;\r\nconst T0 = 0x11A7;\r\nconst L_COUNT = 19;\r\nconst V_COUNT = 21;\r\nconst T_COUNT = 28;\r\nconst N_COUNT = V_COUNT * T_COUNT;\r\nconst S_COUNT = L_COUNT * N_COUNT;\r\nconst S1 = S0 + S_COUNT;\r\nconst L1 = L0 + L_COUNT;\r\nconst V1 = V0 + V_COUNT;\r\nconst T1 = T0 + T_COUNT;\r\n\r\nfunction is_hangul(cp) {\r\n\treturn cp >= S0 && cp < S1;\r\n}\r\n\r\nfunction compose_pair(a, b) {\r\n\tif (a >= L0 && a < L1 && b >= V0 && b < V1) {\r\n\t\treturn S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;\r\n\t} else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {\r\n\t\treturn a + (b - T0);\r\n\t} else {\r\n\t\tlet recomp = RECOMP.get(a);\r\n\t\tif (recomp) {\r\n\t\t\trecomp = recomp.get(b);\r\n\t\t\tif (recomp) {\r\n\t\t\t\treturn recomp;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n}\r\n\r\nfunction decomposed(cps) {\r\n\tlet ret = [];\r\n\tlet buf = [];\r\n\tlet check_order = false;\r\n\tfunction add(cp) {\r\n\t\tlet cc = SHIFTED_RANK.get(cp);\r\n\t\tif (cc) {\r\n\t\t\tcheck_order = true;\r\n\t\t\tcp |= cc;\r\n\t\t}\r\n\t\tret.push(cp);\r\n\t}\r\n\tfor (let cp of cps) {\r\n\t\twhile (true) {\r\n\t\t\tif (cp < 0x80) {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t} else if (is_hangul(cp)) {\r\n\t\t\t\tlet s_index = cp - S0;\r\n\t\t\t\tlet l_index = s_index / N_COUNT | 0;\r\n\t\t\t\tlet v_index = (s_index % N_COUNT) / T_COUNT | 0;\r\n\t\t\t\tlet t_index = s_index % T_COUNT;\r\n\t\t\t\tadd(L0 + l_index);\r\n\t\t\t\tadd(V0 + v_index);\r\n\t\t\t\tif (t_index > 0) add(T0 + t_index);\r\n\t\t\t} else {\r\n\t\t\t\tlet mapped = DECOMP.get(cp);\r\n\t\t\t\tif (mapped) {\r\n\t\t\t\t\tbuf.push(...mapped);\r\n\t\t\t\t} else {\r\n\t\t\t\t\tadd(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (!buf.length) break;\r\n\t\t\tcp = buf.pop();\r\n\t\t}\r\n\t}\r\n\tif (check_order && ret.length > 1) {\r\n\t\tlet prev_cc = unpack_cc(ret[0]);\r\n\t\tfor (let i = 1; i < ret.length; i++) {\r\n\t\t\tlet cc = unpack_cc(ret[i]);\r\n\t\t\tif (cc == 0 || prev_cc <= cc) {\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tlet j = i-1;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet tmp = ret[j+1];\r\n\t\t\t\tret[j+1] = ret[j];\r\n\t\t\t\tret[j] = tmp;\r\n\t\t\t\tif (!j) break;\r\n\t\t\t\tprev_cc = unpack_cc(ret[--j]);\r\n\t\t\t\tif (prev_cc <= cc) break;\r\n\t\t\t}\r\n\t\t\tprev_cc = unpack_cc(ret[i]);\r\n\t\t}\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction composed_from_decomposed(v) {\r\n\tlet ret = [];\r\n\tlet stack = [];\r\n\tlet prev_cp = -1;\r\n\tlet prev_cc = 0;\r\n\tfor (let packed of v) {\r\n\t\tlet cc = unpack_cc(packed);\r\n\t\tlet cp = unpack_cp(packed);\r\n\t\tif (prev_cp == -1) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tret.push(cp);\r\n\t\t\t}\r\n\t\t} else if (prev_cc > 0 && prev_cc >= cc) {\r\n\t\t\tif (cc == 0) {\r\n\t\t\t\tret.push(prev_cp, ...stack);\r\n\t\t\t\tstack.length = 0;\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t}\r\n\t\t\tprev_cc = cc;\r\n\t\t} else {\r\n\t\t\tlet composed = compose_pair(prev_cp, cp);\r\n\t\t\tif (composed >= 0) {\r\n\t\t\t\tprev_cp = composed;\r\n\t\t\t} else if (prev_cc == 0 && cc == 0) {\r\n\t\t\t\tret.push(prev_cp);\r\n\t\t\t\tprev_cp = cp;\r\n\t\t\t} else {\r\n\t\t\t\tstack.push(cp);\r\n\t\t\t\tprev_cc = cc;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (prev_cp >= 0) {\r\n\t\tret.push(prev_cp, ...stack);\t\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\n// note: cps can be iterable\r\nfunction nfd(cps) {\r\n\treturn decomposed(cps).map(unpack_cp);\r\n}\r\nfunction nfc(cps) {\r\n\treturn composed_from_decomposed(decomposed(cps));\r\n}\n\n//const t0 = performance.now();\r\n\r\nconst STOP = 0x2E;\r\nconst FE0F = 0xFE0F;\r\nconst STOP_CH = '.';\r\nconst UNIQUE_PH = 1;\r\nconst HYPHEN = 0x2D;\r\n\r\nfunction read_set() {\r\n\treturn new Set(read_sorted(r$1));\r\n}\r\nconst MAPPED = new Map(read_mapped(r$1)); \r\nconst IGNORED = read_set(); // ignored characters are not valid, so just read raw codepoints\r\n/*\r\n// direct include from payload is smaller that the decompression code\r\nconst FENCED = new Map(read_array_while(() => {\r\n\tlet cp = r();\r\n\tif (cp) return [cp, read_str(r())];\r\n}));\r\n*/\r\n// 20230217: we still need all CM for proper error formatting\r\n// but norm only needs NSM subset that are potentially-valid\r\nconst CM = read_set();\r\nconst NSM = new Set(read_sorted(r$1).map(function(i) { return this[i]; }, [...CM]));\r\n/*\r\nconst CM_SORTED = read_sorted(r);\r\nconst NSM = new Set(read_sorted(r).map(i => CM_SORTED[i]));\r\nconst CM = new Set(CM_SORTED);\r\n*/\r\nconst ESCAPE = read_set(); // characters that should not be printed\r\nconst NFC_CHECK = read_set();\r\nconst CHUNKS = read_sorted_arrays(r$1);\r\nfunction read_chunked() {\r\n\t// deduplicated sets + uniques\r\n\treturn new Set([read_sorted(r$1).map(i => CHUNKS[i]), read_sorted(r$1)].flat(2));\r\n}\r\nconst UNRESTRICTED = r$1();\r\nconst GROUPS = read_array_while(i => {\r\n\t// minifier property mangling seems unsafe\r\n\t// so these are manually renamed to single chars\r\n\tlet N = read_array_while(r$1).map(x => x+0x60);\r\n\tif (N.length) {\r\n\t\tlet R = i >= UNRESTRICTED; // first arent restricted\r\n\t\tN[0] -= 32; // capitalize\r\n\t\tN = str_from_cps(N);\r\n\t\tif (R) N=`Restricted[${N}]`;\r\n\t\tlet P = read_chunked(); // primary\r\n\t\tlet Q = read_chunked(); // secondary\r\n\t\tlet V = [...P, ...Q].sort((a, b) => a-b); // derive: sorted valid\r\n\t\t//let M = r()-1; // combining mark\r\n\t\tlet M = !r$1(); // not-whitelisted, check for NSM\r\n\t\t// code currently isn't needed\r\n\t\t/*if (M < 0) { // whitelisted\r\n\t\t\tM = new Map(read_array_while(() => {\r\n\t\t\t\tlet i = r();\r\n\t\t\t\tif (i) return [V[i-1], read_array_while(() => {\r\n\t\t\t\t\tlet v = read_array_while(r);\r\n\t\t\t\t\tif (v.length) return v.map(x => x-1);\r\n\t\t\t\t})];\r\n\t\t\t}));\r\n\t\t}*/\r\n\t\treturn {N, P, M, R, V: new Set(V)};\r\n\t}\r\n});\r\nconst WHOLE_VALID = read_set();\r\nconst WHOLE_MAP = new Map();\r\n// decode compressed wholes\r\n[...WHOLE_VALID, ...read_set()].sort((a, b) => a-b).map((cp, i, v) => {\r\n\tlet d = r$1(); \r\n\tlet w = v[i] = d ? v[i-d] : {V: [], M: new Map()};\r\n\tw.V.push(cp); // add to member set\r\n\tif (!WHOLE_VALID.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, w);  // register with whole map\r\n\t}\r\n});\r\n// compute confusable-extent complements\r\nfor (let {V, M} of new Set(WHOLE_MAP.values())) {\r\n\t// connect all groups that have each whole character\r\n\tlet recs = [];\r\n\tfor (let cp of V) {\r\n\t\tlet gs = GROUPS.filter(g => g.V.has(cp));\r\n\t\tlet rec = recs.find(({G}) => gs.some(g => G.has(g)));\r\n\t\tif (!rec) {\r\n\t\t\trec = {G: new Set(), V: []};\r\n\t\t\trecs.push(rec);\r\n\t\t}\r\n\t\trec.V.push(cp);\r\n\t\tgs.forEach(g => rec.G.add(g));\r\n\t}\r\n\t// per character cache groups which are not a member of the extent\r\n\tlet union = recs.flatMap(({G}) => [...G]);\r\n\tfor (let {G, V} of recs) {\r\n\t\tlet complement = new Set(union.filter(g => !G.has(g)));\r\n\t\tfor (let cp of V) {\r\n\t\t\tM.set(cp, complement);\r\n\t\t}\r\n\t}\r\n}\r\nlet union = new Set(); // exists in 1+ groups\r\nlet multi = new Set(); // exists in 2+ groups\r\nfor (let g of GROUPS) {\r\n\tfor (let cp of g.V) {\r\n\t\t(union.has(cp) ? multi : union).add(cp);\r\n\t}\r\n}\r\n// dual purpose WHOLE_MAP: return placeholder if unique non-confusable\r\nfor (let cp of union) {\r\n\tif (!WHOLE_MAP.has(cp) && !multi.has(cp)) {\r\n\t\tWHOLE_MAP.set(cp, UNIQUE_PH);\r\n\t}\r\n}\r\nconst VALID = new Set([...union, ...nfd(union)]); // possibly valid\r\n\r\n// decode emoji\r\nconst EMOJI_SORTED = read_sorted(r$1); // temporary\r\n//const EMOJI_SOLO = new Set(read_sorted(r).map(i => EMOJI_SORTED[i])); // not needed\r\nconst EMOJI_ROOT = read_emoji_trie([]);\r\nfunction read_emoji_trie(cps) {\r\n\tlet B = read_array_while(() => {\r\n\t\tlet keys = read_sorted(r$1).map(i => EMOJI_SORTED[i]);\r\n\t\tif (keys.length) return read_emoji_trie(keys);\r\n\t}).sort((a, b) => b.Q.size - a.Q.size); // sort by likelihood\r\n\tlet temp = r$1();\r\n\tlet V = temp % 3; // valid (0 = false, 1 = true, 2 = weird)\r\n\ttemp = (temp / 3)|0;\r\n\tlet F = temp & 1; // allow FE0F\r\n\ttemp >>= 1;\r\n\tlet S = temp & 1; // save\r\n\tlet C = temp & 2; // check\r\n\treturn {B, V, F, S, C, Q: new Set(cps)};\r\n}\r\n//console.log(performance.now() - t0);\r\n\r\n// free tagging system\r\nclass Emoji extends Array {\r\n\tget is_emoji() { return true; }\r\n}\r\n\r\n// create a safe to print string \r\n// invisibles are escaped\r\n// leading cm uses placeholder\r\n// quoter(cp) => string, eg. 3000 => \"{3000}\"\r\n// note: in html, you'd call this function then replace [<>&] with entities\r\nfunction safe_str_from_cps(cps, quoter = quote_cp) {\r\n\t//if (Number.isInteger(cps)) cps = [cps];\r\n\t//if (!Array.isArray(cps)) throw new TypeError(`expected codepoints`);\r\n\tlet buf = [];\r\n\tif (is_combining_mark(cps[0])) buf.push('◌');\r\n\tlet prev = 0;\r\n\tlet n = cps.length;\r\n\tfor (let i = 0; i < n; i++) {\r\n\t\tlet cp = cps[i];\r\n\t\tif (should_escape(cp)) {\r\n\t\t\tbuf.push(str_from_cps(cps.slice(prev, i)));\r\n\t\t\tbuf.push(quoter(cp));\r\n\t\t\tprev = i + 1;\r\n\t\t}\r\n\t}\r\n\tbuf.push(str_from_cps(cps.slice(prev, n)));\r\n\treturn buf.join('');\r\n}\r\n\r\n// if escaped: {HEX}\r\n//       else: \"x\" {HEX}\r\nfunction quoted_cp(cp) {\r\n\treturn (should_escape(cp) ? '' : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);\r\n}\r\n\r\n// 20230211: some messages can be mixed-directional and result in spillover\r\n// use 200E after a quoted string to force the remainder of a string from \r\n// acquring the direction of the quote\r\n// https://www.w3.org/International/questions/qa-bidi-unicode-controls#exceptions\r\nfunction bidi_qq(s) {\r\n\treturn `\"${s}\"\\u200E`; // strong LTR\r\n}\r\n\r\nfunction check_label_extension(cps) {\r\n\tif (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {\r\n\t\tthrow new Error('invalid label extension');\r\n\t}\r\n}\r\nfunction check_leading_underscore(cps) {\r\n\tconst UNDERSCORE = 0x5F;\r\n\tfor (let i = cps.lastIndexOf(UNDERSCORE); i > 0; ) {\r\n\t\tif (cps[--i] !== UNDERSCORE) {\r\n\t\t\tthrow new Error('underscore allowed only at start');\r\n\t\t}\r\n\t}\r\n}\r\n// check that a fenced cp is not leading, trailing, or touching another fenced cp\r\nfunction check_fenced(cps) {\r\n\tlet cp = cps[0];\r\n\tlet prev = FENCED.get(cp);\r\n\tif (prev) throw error_placement(`leading ${prev}`);\r\n\tlet n = cps.length;\r\n\tlet last = -1; // prevents trailing from throwing\r\n\tfor (let i = 1; i < n; i++) {\r\n\t\tcp = cps[i];\r\n\t\tlet match = FENCED.get(cp);\r\n\t\tif (match) {\r\n\t\t\t// since cps[0] isn't fenced, cps[1] cannot throw\r\n\t\t\tif (last == i) throw error_placement(`${prev} + ${match}`);\r\n\t\t\tlast = i + 1;\r\n\t\t\tprev = match;\r\n\t\t}\r\n\t}\r\n\tif (last == n) throw error_placement(`trailing ${prev}`);\r\n}\r\n\r\n// note: set(s) cannot be exposed because they can be modified\r\nfunction is_combining_mark(cp) {\r\n\treturn CM.has(cp);\r\n}\r\nfunction should_escape(cp) {\r\n\treturn ESCAPE.has(cp);\r\n}\r\n\r\nfunction ens_normalize_fragment(frag, decompose) {\r\n\tlet nf = decompose ? nfd : nfc;\r\n\treturn frag.split(STOP_CH).map(label => str_from_cps(process(explode_cp(label), nf).flatMap(x => x.is_emoji ? filter_fe0f(x) : x))).join(STOP_CH);\r\n}\r\n\r\nfunction ens_normalize(name) {\r\n\treturn flatten(ens_split(name));\r\n}\r\n\r\nfunction ens_beautify(name) {\r\n\tlet split = ens_split(name, true);\r\n\t// this is experimental\r\n\tfor (let {type, output, error} of split) {\r\n\t\tif (error) continue;\r\n\r\n\t\t// replace leading/trailing hyphen\r\n\t\t// 20230121: consider beautifing all or leading/trailing hyphen to unicode variant\r\n\t\t// not exactly the same in every font, but very similar: \"-\" vs \"‐\"\r\n\t\t/*\r\n\t\tconst UNICODE_HYPHEN = 0x2010;\r\n\t\t// maybe this should replace all for visual consistancy?\r\n\t\t// `node tools/reg-count.js regex ^-\\{2,\\}` => 592\r\n\t\t//for (let i = 0; i < output.length; i++) if (output[i] == 0x2D) output[i] = 0x2010;\r\n\t\tif (output[0] == HYPHEN) output[0] = UNICODE_HYPHEN;\r\n\t\tlet end = output.length-1;\r\n\t\tif (output[end] == HYPHEN) output[end] = UNICODE_HYPHEN;\r\n\t\t*/\r\n\t\t// 20230123: WHATWG URL uses \"CheckHyphens\" false\r\n\t\t// https://url.spec.whatwg.org/#idna\r\n\r\n\t\t// update ethereum symbol\r\n\t\t// ξ => Ξ if not greek\r\n\t\tif (type !== 'Greek') { \r\n\t\t\tlet prev = 0;\r\n\t\t\twhile (true) {\r\n\t\t\t\tlet next = output.indexOf(0x3BE, prev);\r\n\t\t\t\tif (next < 0) break;\r\n\t\t\t\toutput[next] = 0x39E; \r\n\t\t\t\tprev = next + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 20221213: fixes bidi subdomain issue, but breaks invariant (200E is disallowed)\r\n\t\t// could be fixed with special case for: 2D (.) + 200E (LTR)\r\n\t\t//output.splice(0, 0, 0x200E);\r\n\t}\r\n\treturn flatten(split);\r\n}\r\n\r\nfunction ens_split(name, preserve_emoji) {\r\n\tlet offset = 0;\r\n\t// https://unicode.org/reports/tr46/#Validity_Criteria\r\n\t// 4.) \"The label must not contain a U+002E ( . ) FULL STOP.\"\r\n\treturn name.split(STOP_CH).map(label => {\r\n\t\tlet input = explode_cp(label);\r\n\t\tlet info = {\r\n\t\t\tinput,\r\n\t\t\toffset, // codepoint, not substring!\r\n\t\t};\r\n\t\toffset += input.length + 1; // + stop\r\n\t\tlet norm;\r\n\t\ttry {\r\n\t\t\t// 1.) \"The label must be in Unicode Normalization Form NFC\"\r\n\t\t\tlet tokens = info.tokens = process(input, nfc); // if we parse, we get [norm and mapped]\r\n\t\t\tlet token_count = tokens.length;\r\n\t\t\tlet type;\r\n\t\t\tif (!token_count) { // the label was effectively empty (could of had ignored characters)\r\n\t\t\t\t// 20230120: change to strict\r\n\t\t\t\t// https://discuss.ens.domains/t/ens-name-normalization-2nd/14564/59\r\n\t\t\t\t//norm = [];\r\n\t\t\t\t//type = 'None'; // use this instead of next match, \"ASCII\"\r\n\t\t\t\tthrow new Error(`empty label`);\r\n\t\t\t} else {\r\n\t\t\t\tlet chars = tokens[0];\r\n\t\t\t\tlet emoji = token_count > 1 || chars.is_emoji;\r\n\t\t\t\tif (!emoji && chars.every(cp => cp < 0x80)) { // special case for ascii\r\n\t\t\t\t\tnorm = chars;\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\t// only needed for ascii\r\n\t\t\t\t\t// 20230123: matches matches WHATWG, see note 3.3\r\n\t\t\t\t\tcheck_label_extension(norm);\r\n\t\t\t\t\t// cant have fenced\r\n\t\t\t\t\t// cant have cm\r\n\t\t\t\t\t// cant have wholes\r\n\t\t\t\t\t// see derive: \"Fastpath ASCII\"\r\n\t\t\t\t\ttype = 'ASCII';\r\n\t\t\t\t} else {\r\n\t\t\t\t\tif (emoji) { // there is at least one emoji\r\n\t\t\t\t\t\tinfo.emoji = true; \r\n\t\t\t\t\t\tchars = tokens.flatMap(x => x.is_emoji ? [] : x); // all of the nfc tokens concat together\r\n\t\t\t\t\t}\r\n\t\t\t\t\tnorm = tokens.flatMap(x => !preserve_emoji && x.is_emoji ? filter_fe0f(x) : x);\r\n\t\t\t\t\tcheck_leading_underscore(norm);\r\n\t\t\t\t\tif (!chars.length) { // theres no text, just emoji\r\n\t\t\t\t\t\ttype = 'Emoji';\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\t// 5. \"The label must not begin with a combining mark, that is: General_Category=Mark.\"\r\n\t\t\t\t\t\tif (CM.has(norm[0])) throw error_placement('leading combining mark');\r\n\t\t\t\t\t\tfor (let i = 1; i < token_count; i++) { // we've already checked the first token\r\n\t\t\t\t\t\t\tlet cps = tokens[i];\r\n\t\t\t\t\t\t\tif (!cps.is_emoji && CM.has(cps[0])) { // every text token has emoji neighbors, eg. EtEEEtEt...\r\n\t\t\t\t\t\t\t\t// bidi_qq() not needed since emoji is LTR and cps is a CM\r\n\t\t\t\t\t\t\t\tthrow error_placement(`emoji + combining mark: \"${str_from_cps(tokens[i-1])} + ${safe_str_from_cps([cps[0]])}\"`); \r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcheck_fenced(norm);\r\n\t\t\t\t\t\tlet unique = [...new Set(chars)];\r\n\t\t\t\t\t\tlet [g] = determine_group(unique); // take the first match\r\n\t\t\t\t\t\t// see derive: \"Matching Groups have Same CM Style\"\r\n\t\t\t\t\t\t// alternative: could form a hybrid type: Latin/Japanese/...\t\r\n\t\t\t\t\t\tcheck_group(g, chars); // need text in order\r\n\t\t\t\t\t\tcheck_whole(g, unique); // only need unique text (order would be required for multiple-char confusables)\r\n\t\t\t\t\t\ttype = g.N;\r\n\t\t\t\t\t\t// 20230121: consider exposing restricted flag\r\n\t\t\t\t\t\t// it's simpler to just check for 'Restricted'\r\n\t\t\t\t\t\t// or even better: type.endsWith(']')\r\n\t\t\t\t\t\t//if (g.R) info.restricted = true;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tinfo.type = type;\r\n\t\t} catch (err) {\r\n\t\t\tinfo.error = err; // use full error object\r\n\t\t}\r\n\t\tinfo.output = norm;\r\n\t\treturn info;\r\n\t});\r\n}\r\n\r\nfunction check_whole(group, unique) {\r\n\tlet maker;\r\n\tlet shared = []; // TODO: can this be avoided?\r\n\tfor (let cp of unique) {\r\n\t\tlet whole = WHOLE_MAP.get(cp);\r\n\t\tif (whole === UNIQUE_PH) return; // unique, non-confusable\r\n\t\tif (whole) {\r\n\t\t\tlet set = whole.M.get(cp); // groups which have a character that look-like this character\r\n\t\t\tmaker = maker ? maker.filter(g => set.has(g)) : [...set];\r\n\t\t\tif (!maker.length) return; // confusable intersection is empty\r\n\t\t} else {\r\n\t\t\tshared.push(cp); \r\n\t\t}\r\n\t}\r\n\tif (maker) {\r\n\t\t// we have 1+ confusable\r\n\t\t// check if any of the remaning groups\r\n\t\t// contain the shared characters too\r\n\t\tfor (let g of maker) {\r\n\t\t\tif (shared.every(cp => g.V.has(cp))) {\r\n\t\t\t\tthrow new Error(`whole-script confusable: ${group.N}/${g.N}`);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// assumption: unique.size > 0\r\n// returns list of matching groups\r\nfunction determine_group(unique) {\r\n\tlet groups = GROUPS;\r\n\tfor (let cp of unique) {\r\n\t\t// note: we need to dodge CM that are whitelisted\r\n\t\t// but that code isn't currently necessary\r\n\t\tlet gs = groups.filter(g => g.V.has(cp));\r\n\t\tif (!gs.length) {\r\n\t\t\tif (groups === GROUPS) {\r\n\t\t\t\t// the character was composed of valid parts\r\n\t\t\t\t// but it's NFC form is invalid\r\n\t\t\t\tthrow error_disallowed(cp); // this should be rare\r\n\t\t\t} else {\r\n\t\t\t\t// there is no group that contains all these characters\r\n\t\t\t\t// throw using the highest priority group that matched\r\n\t\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\t\tthrow error_group_member(groups[0], cp);\r\n\t\t\t}\r\n\t\t}\r\n\t\tgroups = gs;\r\n\t\tif (gs.length == 1) break; // there is only one group left\r\n\t}\r\n\t// there are at least 1 group(s) with all of these characters\r\n\treturn groups;\r\n}\r\n\r\n// throw on first error\r\nfunction flatten(split) {\r\n\treturn split.map(({input, error, output}) => {\r\n\t\tif (error) {\r\n\t\t\t// don't print label again if just a single label\r\n\t\t\tlet msg = error.message;\r\n\t\t\t// bidi_qq() only necessary if msg is digits\r\n\t\t\tthrow new Error(split.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input))}: ${msg}`); \r\n\t\t}\r\n\t\treturn str_from_cps(output);\r\n\t}).join(STOP_CH);\r\n}\r\n\r\nfunction error_disallowed(cp) {\r\n\t// TODO: add cp to error?\r\n\treturn new Error(`disallowed character: ${quoted_cp(cp)}`); \r\n}\r\nfunction error_group_member(g, cp) {\r\n\tlet quoted = quoted_cp(cp);\r\n\tlet gg = GROUPS.find(g => g.P.has(cp));\r\n\tif (gg) {\r\n\t\tquoted = `${gg.N} ${quoted}`;\r\n\t}\r\n\treturn new Error(`illegal mixture: ${g.N} + ${quoted}`);\r\n}\r\nfunction error_placement(where) {\r\n\treturn new Error(`illegal placement: ${where}`);\r\n}\r\n\r\n// assumption: cps.length > 0\r\n// assumption: cps[0] isn't a CM\r\n// assumption: the previous character isn't an emoji\r\nfunction check_group(g, cps) {\r\n\tlet {V, M} = g;\r\n\tfor (let cp of cps) {\r\n\t\tif (!V.has(cp)) {\r\n\t\t\t// for whitelisted scripts, this will throw illegal mixture on invalid cm, eg. \"e{300}{300}\"\r\n\t\t\t// at the moment, it's unnecessary to introduce an extra error type\r\n\t\t\t// until there exists a whitelisted multi-character\r\n\t\t\t//   eg. if (M < 0 && is_combining_mark(cp)) { ... }\r\n\t\t\t// there are 3 cases:\r\n\t\t\t//   1. illegal cm for wrong group => mixture error\r\n\t\t\t//   2. illegal cm for same group => cm error\r\n\t\t\t//       requires set of whitelist cm per group: \r\n\t\t\t//        eg. new Set([...g.V].flatMap(nfc).filter(cp => CM.has(cp)))\r\n\t\t\t//   3. wrong group => mixture error\r\n\t\t\tthrow error_group_member(g, cp);\r\n\t\t}\r\n\t}\r\n\t//if (M >= 0) { // we have a known fixed cm count\r\n\tif (M) { // we need to check for NSM\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // see: assumption\r\n\t\t\t// 20230210: bugfix: using cps instead of decomposed h/t Carbon225\r\n\t\t\t/*\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: ${g.N} ${bidi_qq(str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t\t*/\r\n\t\t\t// 20230217: switch to NSM counting\r\n\t\t\t// https://www.unicode.org/reports/tr39/#Optional_Detection\r\n\t\t\tif (NSM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\tfor (let cp; j < e && NSM.has(cp = decomposed[j]); j++) {\r\n\t\t\t\t\t// a. Forbid sequences of the same nonspacing mark.\r\n\t\t\t\t\tfor (let k = i; k < j; k++) { // O(n^2) but n < 100\r\n\t\t\t\t\t\tif (decomposed[k] == cp) {\r\n\t\t\t\t\t\t\tthrow new Error(`non-spacing marks: repeated ${quoted_cp(cp)}`);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// parse to end so we have full nsm count\r\n\t\t\t\t// b. Forbid sequences of more than 4 nonspacing marks (gc=Mn or gc=Me).\r\n\t\t\t\tif (j - i > NSM_MAX) {\r\n\t\t\t\t\t// note: this slice starts with a base char or spacing-mark cm\r\n\t\t\t\t\tthrow new Error(`non-spacing marks: too many ${bidi_qq(safe_str_from_cps(decomposed.slice(i-1, j)))} (${j-i}/${NSM_MAX})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t// *** this code currently isn't needed ***\r\n\t/*\r\n\tlet cm_whitelist = M instanceof Map;\r\n\tfor (let i = 0, e = cps.length; i < e; ) {\r\n\t\tlet cp = cps[i++];\r\n\t\tlet seqs = cm_whitelist && M.get(cp);\r\n\t\tif (seqs) { \r\n\t\t\t// list of codepoints that can follow\r\n\t\t\t// if this exists, this will always be 1+\r\n\t\t\tlet j = i;\r\n\t\t\twhile (j < e && CM.has(cps[j])) j++;\r\n\t\t\tlet cms = cps.slice(i, j);\r\n\t\t\tlet match = seqs.find(seq => !compare_arrays(seq, cms));\r\n\t\t\tif (!match) throw new Error(`disallowed combining mark sequence: \"${safe_str_from_cps([cp, ...cms])}\"`);\r\n\t\t\ti = j;\r\n\t\t} else if (!V.has(cp)) {\r\n\t\t\t// https://www.unicode.org/reports/tr39/#mixed_script_confusables\r\n\t\t\tlet quoted = quoted_cp(cp);\r\n\t\t\tfor (let cp of cps) {\r\n\t\t\t\tlet u = UNIQUE.get(cp);\r\n\t\t\t\tif (u && u !== g) {\r\n\t\t\t\t\t// if both scripts are restricted this error is confusing\r\n\t\t\t\t\t// because we don't differentiate RestrictedA from RestrictedB \r\n\t\t\t\t\tif (!u.R) quoted = `${quoted} is ${u.N}`;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tthrow new Error(`disallowed ${g.N} character: ${quoted}`);\r\n\t\t\t//throw new Error(`disallowed character: ${quoted} (expected ${g.N})`);\r\n\t\t\t//throw new Error(`${g.N} does not allow: ${quoted}`);\r\n\t\t}\r\n\t}\r\n\tif (!cm_whitelist) {\r\n\t\tlet decomposed = nfd(cps);\r\n\t\tfor (let i = 1, e = decomposed.length; i < e; i++) { // we know it can't be cm leading\r\n\t\t\tif (CM.has(decomposed[i])) {\r\n\t\t\t\tlet j = i + 1;\r\n\t\t\t\twhile (j < e && CM.has(decomposed[j])) j++;\r\n\t\t\t\tif (j - i > M) {\r\n\t\t\t\t\tthrow new Error(`too many combining marks: \"${str_from_cps(decomposed.slice(i-1, j))}\" (${j-i}/${M})`);\r\n\t\t\t\t}\r\n\t\t\t\ti = j;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t*/\r\n}\r\n\r\n// given a list of codepoints\r\n// returns a list of lists, where emoji are a fully-qualified (as Array subclass)\r\n// eg. explode_cp(\"abc💩d\") => [[61, 62, 63], Emoji[1F4A9, FE0F], [64]]\r\nfunction process(input, nf) {\r\n\tlet ret = [];\r\n\tlet chars = [];\r\n\tinput = input.slice().reverse(); // flip so we can pop\r\n\twhile (input.length) {\r\n\t\tlet emoji = consume_emoji_reversed(input);\r\n\t\tif (emoji) {\r\n\t\t\tif (chars.length) {\r\n\t\t\t\tret.push(nf(chars));\r\n\t\t\t\tchars = [];\r\n\t\t\t}\r\n\t\t\tret.push(emoji);\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (VALID.has(cp)) {\r\n\t\t\t\tchars.push(cp);\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\tchars.push(...cps);\r\n\t\t\t\t} else if (!IGNORED.has(cp)) {\r\n\t\t\t\t\tthrow error_disallowed(cp);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (chars.length) {\r\n\t\tret.push(nf(chars));\r\n\t}\r\n\treturn ret;\r\n}\r\n\r\nfunction filter_fe0f(cps) {\r\n\treturn cps.filter(cp => cp != FE0F);\r\n}\r\n\r\n// given array of codepoints\r\n// returns the longest valid emoji sequence (or undefined if no match)\r\n// *MUTATES* the supplied array\r\n// allows optional FE0F\r\n// disallows interleaved ignored characters\r\n// fills (optional) eaten array with matched codepoints\r\nfunction consume_emoji_reversed(cps, eaten) {\r\n\tlet node = EMOJI_ROOT;\r\n\tlet emoji;\r\n\tlet saved;\r\n\tlet stack = [];\r\n\tlet pos = cps.length;\r\n\tif (eaten) eaten.length = 0; // clear input buffer (if needed)\r\n\twhile (pos) {\r\n\t\tlet cp = cps[--pos];\r\n\t\tnode = node.B.find(x => x.Q.has(cp));\r\n\t\tif (!node) break;\r\n\t\tif (node.S) { // remember\r\n\t\t\tsaved = cp;\r\n\t\t} else if (node.C) { // check exclusion\r\n\t\t\tif (cp === saved) break;\r\n\t\t}\r\n\t\tstack.push(cp);\r\n\t\tif (node.F) {\r\n\t\t\tstack.push(FE0F);\r\n\t\t\tif (pos > 0 && cps[pos - 1] == FE0F) pos--; // consume optional FE0F\r\n\t\t}\r\n\t\tif (node.V) { // this is a valid emoji (so far)\r\n\t\t\temoji = conform_emoji_copy(stack, node);\r\n\t\t\tif (eaten) eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\r\n\t\t\tcps.length = pos; // truncate\r\n\t\t}\r\n\t}\r\n\t/*\r\n\t// *** this code currently isn't needed ***\r\n\tif (!emoji) {\r\n\t\tlet cp = cps[cps.length-1];\r\n\t\tif (EMOJI_SOLO.has(cp)) {\r\n\t\t\tif (eaten) eaten.push(cp);\r\n\t\t\temoji = Emoji.of(cp);\r\n\t\t\tcps.pop();\r\n\t\t}\r\n\t}\r\n\t*/\r\n\treturn emoji;\r\n}\r\n\r\n// create a copy and fix any unicode quirks\r\nfunction conform_emoji_copy(cps, node) {\r\n\tlet copy = Emoji.from(cps); // copy stack\r\n\tif (node.V == 2) copy.splice(1, 1); // delete FE0F at position 1 (see: make.js)\r\n\treturn copy;\r\n}\r\n\r\n// return all supported emoji as fully-qualified emoji \r\n// ordered by length then lexicographic \r\nfunction ens_emoji() {\r\n\t// *** this code currently isn't needed ***\r\n\t//let ret = [...EMOJI_SOLO].map(x => [x]);\r\n\tlet ret = [];\r\n\tbuild(EMOJI_ROOT, []);\r\n\treturn ret.sort(compare_arrays);\r\n\tfunction build(node, cps, saved) {\r\n\t\tif (node.S) { \r\n\t\t\tsaved = cps[cps.length-1];\r\n\t\t} else if (node.C) { \r\n\t\t\tif (saved === cps[cps.length-1]) return;\r\n\t\t}\r\n\t\tif (node.F) cps.push(FE0F);\r\n\t\tif (node.V) ret.push(conform_emoji_copy(cps, node));\r\n\t\tfor (let br of node.B) {\r\n\t\t\tfor (let cp of br.Q) {\r\n\t\t\t\tbuild(br, [...cps, cp], saved);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n\r\n// ************************************************************\r\n// tokenizer \r\n\r\nconst TY_VALID = 'valid';\r\nconst TY_MAPPED = 'mapped';\r\nconst TY_IGNORED = 'ignored';\r\nconst TY_DISALLOWED = 'disallowed';\r\nconst TY_EMOJI = 'emoji';\r\nconst TY_NFC = 'nfc';\r\nconst TY_STOP = 'stop';\r\n\r\nfunction ens_tokenize(name, {\r\n\tnf = true, // collapse unnormalized runs into a single token\r\n} = {}) {\r\n\tlet input = explode_cp(name).reverse();\r\n\tlet eaten = [];\r\n\tlet tokens = [];\r\n\twhile (input.length) {\t\t\r\n\t\tlet emoji = consume_emoji_reversed(input, eaten);\r\n\t\tif (emoji) {\r\n\t\t\ttokens.push({type: TY_EMOJI, emoji, input: eaten.slice(), cps: filter_fe0f(emoji)});\r\n\t\t} else {\r\n\t\t\tlet cp = input.pop();\r\n\t\t\tif (cp == STOP) {\r\n\t\t\t\ttokens.push({type: TY_STOP, cp});\r\n\t\t\t} else if (VALID.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_VALID, cps: [cp]});\r\n\t\t\t} else if (IGNORED.has(cp)) {\r\n\t\t\t\ttokens.push({type: TY_IGNORED, cp});\r\n\t\t\t} else {\r\n\t\t\t\tlet cps = MAPPED.get(cp);\r\n\t\t\t\tif (cps) {\r\n\t\t\t\t\ttokens.push({type: TY_MAPPED, cp, cps: cps.slice()});\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokens.push({type: TY_DISALLOWED, cp});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tif (nf) {\r\n\t\tfor (let i = 0, start = -1; i < tokens.length; i++) {\r\n\t\t\tlet token = tokens[i];\r\n\t\t\tif (is_valid_or_mapped(token.type)) {\r\n\t\t\t\tif (requires_check(token.cps)) { // normalization might be needed\r\n\t\t\t\t\tlet end = i + 1;\r\n\t\t\t\t\tfor (let pos = end; pos < tokens.length; pos++) { // find adjacent text\r\n\t\t\t\t\t\tlet {type, cps} = tokens[pos];\r\n\t\t\t\t\t\tif (is_valid_or_mapped(type)) {\r\n\t\t\t\t\t\t\tif (!requires_check(cps)) break;\r\n\t\t\t\t\t\t\tend = pos + 1;\r\n\t\t\t\t\t\t} else if (type !== TY_IGNORED) { // || type !== TY_DISALLOWED) { \r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (start < 0) start = i;\r\n\t\t\t\t\tlet slice = tokens.slice(start, end);\r\n\t\t\t\t\tlet cps0 = slice.flatMap(x => is_valid_or_mapped(x.type) ? x.cps : []); // strip junk tokens\r\n\t\t\t\t\tlet cps = nfc(cps0);\r\n\t\t\t\t\tif (compare_arrays(cps, cps0)) { // bundle into an nfc token\r\n\t\t\t\t\t\ttokens.splice(start, end - start, {\r\n\t\t\t\t\t\t\ttype: TY_NFC, \r\n\t\t\t\t\t\t\tinput: cps0, // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps\r\n\t\t\t\t\t\t\tcps, \r\n\t\t\t\t\t\t\ttokens0: collapse_valid_tokens(slice),\r\n\t\t\t\t\t\t\ttokens: ens_tokenize(str_from_cps(cps), {nf: false})\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t\ti = start;\r\n\t\t\t\t\t} else { \r\n\t\t\t\t\t\ti = end - 1; // skip to end of slice\r\n\t\t\t\t\t}\r\n\t\t\t\t\tstart = -1; // reset\r\n\t\t\t\t} else {\r\n\t\t\t\t\tstart = i; // remember last\r\n\t\t\t\t}\r\n\t\t\t} else if (token.type !== TY_IGNORED) { // 20221024: is this correct?\r\n\t\t\t\tstart = -1; // reset\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn collapse_valid_tokens(tokens);\r\n}\r\n\r\nfunction is_valid_or_mapped(type) {\r\n\treturn type == TY_VALID || type == TY_MAPPED;\r\n}\r\n\r\nfunction requires_check(cps) {\r\n\treturn cps.some(cp => NFC_CHECK.has(cp));\r\n}\r\n\r\nfunction collapse_valid_tokens(tokens) {\r\n\tfor (let i = 0; i < tokens.length; i++) {\r\n\t\tif (tokens[i].type == TY_VALID) {\r\n\t\t\tlet j = i + 1;\r\n\t\t\twhile (j < tokens.length && tokens[j].type == TY_VALID) j++;\r\n\t\t\ttokens.splice(i, j - i, {type: TY_VALID, cps: tokens.slice(i, j).flatMap(x => x.cps)});\r\n\t\t}\r\n\t}\r\n\treturn tokens;\r\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL0BhZHJhZmZ5K2Vucy1ub3JtYWxpemVAMS45LjAvbm9kZV9tb2R1bGVzL0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUvZGlzdC9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixPQUFPO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsRUFBRSxZQUFZLEdBQUcsOEJBQThCLEVBQUU7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSxtQ0FBbUMsV0FBVztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFFQUFxRTtBQUNyRixJQUFJO0FBQ0o7QUFDQTtBQUNBLGlCQUFpQixrQkFBa0I7QUFDbkMsS0FBSztBQUNMLGlCQUFpQiwwQkFBMEI7QUFDM0MsS0FBSztBQUNMLGlCQUFpQixxQkFBcUI7QUFDdEMsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBa0Isc0NBQXNDO0FBQ3hELE1BQU07QUFDTixrQkFBa0Isd0JBQXdCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsbUJBQW1CO0FBQ2pEO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQSx5QkFBeUIscUJBQXFCLFNBQVM7QUFDdkQsV0FBVyxXQUFXO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0NBQWdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxVQUFVO0FBQzFELE9BQU87QUFDUDtBQUNBLE9BQU87QUFDUCxtQkFBbUI7QUFDbkI7QUFDQSxpQkFBaUI7QUFDakIsTUFBTTtBQUNOLGdCQUFnQjtBQUNoQjtBQUNBLEtBQUssc0NBQXNDO0FBQzNDLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0REFBNEQ7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7O0FBRWtLIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uLi8uLi9ub2RlX21vZHVsZXMvLnBucG0vQGFkcmFmZnkrZW5zLW5vcm1hbGl6ZUAxLjkuMC9ub2RlX21vZHVsZXMvQGFkcmFmZnkvZW5zLW5vcm1hbGl6ZS9kaXN0L2luZGV4LmpzPzIzYjciXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gZGVjb2RlX2FyaXRobWV0aWMoYnl0ZXMpIHtcclxuXHRsZXQgcG9zID0gMDtcclxuXHRmdW5jdGlvbiB1MTYoKSB7IHJldHVybiAoYnl0ZXNbcG9zKytdIDw8IDgpIHwgYnl0ZXNbcG9zKytdOyB9XHJcblx0XHJcblx0Ly8gZGVjb2RlIHRoZSBmcmVxdWVuY3kgdGFibGVcclxuXHRsZXQgc3ltYm9sX2NvdW50ID0gdTE2KCk7XHJcblx0bGV0IHRvdGFsID0gMTtcclxuXHRsZXQgYWNjID0gWzAsIDFdOyAvLyBmaXJzdCBzeW1ib2wgaGFzIGZyZXF1ZW5jeSAxXHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzeW1ib2xfY291bnQ7IGkrKykge1xyXG5cdFx0YWNjLnB1c2godG90YWwgKz0gdTE2KCkpO1xyXG5cdH1cclxuXHJcblx0Ly8gc2tpcCB0aGUgc2l6ZWQtcGF5bG9hZCB0aGF0IHRoZSBsYXN0IDMgc3ltYm9scyBpbmRleCBpbnRvXHJcblx0bGV0IHNraXAgPSB1MTYoKTtcclxuXHRsZXQgcG9zX3BheWxvYWQgPSBwb3M7XHJcblx0cG9zICs9IHNraXA7XHJcblxyXG5cdGxldCByZWFkX3dpZHRoID0gMDtcclxuXHRsZXQgcmVhZF9idWZmZXIgPSAwOyBcclxuXHRmdW5jdGlvbiByZWFkX2JpdCgpIHtcclxuXHRcdGlmIChyZWFkX3dpZHRoID09IDApIHtcclxuXHRcdFx0Ly8gdGhpcyB3aWxsIHJlYWQgYmV5b25kIGVuZCBvZiBidWZmZXJcclxuXHRcdFx0Ly8gYnV0ICh1bmRlZmluZWR8MCkgPT4gemVybyBwYWRcclxuXHRcdFx0cmVhZF9idWZmZXIgPSAocmVhZF9idWZmZXIgPDwgOCkgfCBieXRlc1twb3MrK107XHJcblx0XHRcdHJlYWRfd2lkdGggPSA4O1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIChyZWFkX2J1ZmZlciA+PiAtLXJlYWRfd2lkdGgpICYgMTtcclxuXHR9XHJcblxyXG5cdGNvbnN0IE4gPSAzMTtcclxuXHRjb25zdCBGVUxMID0gMioqTjtcclxuXHRjb25zdCBIQUxGID0gRlVMTCA+Pj4gMTtcclxuXHRjb25zdCBRUlRSID0gSEFMRiA+PiAxO1xyXG5cdGNvbnN0IE1BU0sgPSBGVUxMIC0gMTtcclxuXHJcblx0Ly8gZmlsbCByZWdpc3RlclxyXG5cdGxldCByZWdpc3RlciA9IDA7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBOOyBpKyspIHJlZ2lzdGVyID0gKHJlZ2lzdGVyIDw8IDEpIHwgcmVhZF9iaXQoKTtcclxuXHJcblx0bGV0IHN5bWJvbHMgPSBbXTtcclxuXHRsZXQgbG93ID0gMDtcclxuXHRsZXQgcmFuZ2UgPSBGVUxMOyAvLyB0cmVhdCBsaWtlIGEgZmxvYXRcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHZhbHVlID0gTWF0aC5mbG9vcigoKChyZWdpc3RlciAtIGxvdyArIDEpICogdG90YWwpIC0gMSkgLyByYW5nZSk7XHJcblx0XHRsZXQgc3RhcnQgPSAwO1xyXG5cdFx0bGV0IGVuZCA9IHN5bWJvbF9jb3VudDtcclxuXHRcdHdoaWxlIChlbmQgLSBzdGFydCA+IDEpIHsgLy8gYmluYXJ5IHNlYXJjaFxyXG5cdFx0XHRsZXQgbWlkID0gKHN0YXJ0ICsgZW5kKSA+Pj4gMTtcclxuXHRcdFx0aWYgKHZhbHVlIDwgYWNjW21pZF0pIHtcclxuXHRcdFx0XHRlbmQgPSBtaWQ7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c3RhcnQgPSBtaWQ7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmIChzdGFydCA9PSAwKSBicmVhazsgLy8gZmlyc3Qgc3ltYm9sIGlzIGVuZCBtYXJrXHJcblx0XHRzeW1ib2xzLnB1c2goc3RhcnQpO1xyXG5cdFx0bGV0IGEgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0XSAgIC8gdG90YWwpO1xyXG5cdFx0bGV0IGIgPSBsb3cgKyBNYXRoLmZsb29yKHJhbmdlICogYWNjW3N0YXJ0KzFdIC8gdG90YWwpIC0gMTtcclxuXHRcdHdoaWxlICgoKGEgXiBiKSAmIEhBTEYpID09IDApIHtcclxuXHRcdFx0cmVnaXN0ZXIgPSAocmVnaXN0ZXIgPDwgMSkgJiBNQVNLIHwgcmVhZF9iaXQoKTtcclxuXHRcdFx0YSA9IChhIDw8IDEpICYgTUFTSztcclxuXHRcdFx0YiA9IChiIDw8IDEpICYgTUFTSyB8IDE7XHJcblx0XHR9XHJcblx0XHR3aGlsZSAoYSAmIH5iICYgUVJUUikge1xyXG5cdFx0XHRyZWdpc3RlciA9IChyZWdpc3RlciAmIEhBTEYpIHwgKChyZWdpc3RlciA8PCAxKSAmIChNQVNLID4+PiAxKSkgfCByZWFkX2JpdCgpO1xyXG5cdFx0XHRhID0gKGEgPDwgMSkgXiBIQUxGO1xyXG5cdFx0XHRiID0gKChiIF4gSEFMRikgPDwgMSkgfCBIQUxGIHwgMTtcclxuXHRcdH1cclxuXHRcdGxvdyA9IGE7XHJcblx0XHRyYW5nZSA9IDEgKyBiIC0gYTtcclxuXHR9XHJcblx0bGV0IG9mZnNldCA9IHN5bWJvbF9jb3VudCAtIDQ7XHJcblx0cmV0dXJuIHN5bWJvbHMubWFwKHggPT4geyAvLyBpbmRleCBpbnRvIHBheWxvYWRcclxuXHRcdHN3aXRjaCAoeCAtIG9mZnNldCkge1xyXG5cdFx0XHRjYXNlIDM6IHJldHVybiBvZmZzZXQgKyAweDEwMTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCAxNikgfCAoYnl0ZXNbcG9zX3BheWxvYWQrK10gPDwgOCkgfCBieXRlc1twb3NfcGF5bG9hZCsrXSk7XHJcblx0XHRcdGNhc2UgMjogcmV0dXJuIG9mZnNldCArIDB4MTAwICsgKChieXRlc1twb3NfcGF5bG9hZCsrXSA8PCA4KSB8IGJ5dGVzW3Bvc19wYXlsb2FkKytdKTtcclxuXHRcdFx0Y2FzZSAxOiByZXR1cm4gb2Zmc2V0ICsgYnl0ZXNbcG9zX3BheWxvYWQrK107XHJcblx0XHRcdGRlZmF1bHQ6IHJldHVybiB4IC0gMTtcclxuXHRcdH1cclxuXHR9KTtcclxufVx0XHJcblxyXG4vLyByZXR1cm5zIGFuIGl0ZXJhdG9yIHdoaWNoIHJldHVybnMgdGhlIG5leHQgc3ltYm9sXHJcbmZ1bmN0aW9uIHJlYWRfcGF5bG9hZCh2KSB7XHJcblx0bGV0IHBvcyA9IDA7XHJcblx0cmV0dXJuICgpID0+IHZbcG9zKytdO1xyXG59XHJcbmZ1bmN0aW9uIHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKHMpIHtcclxuXHRyZXR1cm4gcmVhZF9wYXlsb2FkKGRlY29kZV9hcml0aG1ldGljKHVuc2FmZV9hdG9iKHMpKSk7XHJcbn1cclxuXHJcbi8vIHVuc2FmZSBpbiB0aGUgc2Vuc2U6XHJcbi8vIGV4cGVjdGVkIHdlbGwtZm9ybWVkIEJhc2U2NCB3L28gcGFkZGluZyBcclxuZnVuY3Rpb24gdW5zYWZlX2F0b2Iocykge1xyXG5cdGxldCBsb29rdXAgPSBbXTtcclxuXHRbLi4uJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXS5mb3JFYWNoKChjLCBpKSA9PiBsb29rdXBbYy5jaGFyQ29kZUF0KDApXSA9IGkpO1xyXG5cdGxldCBuID0gcy5sZW5ndGg7XHJcblx0bGV0IHJldCA9IG5ldyBVaW50OEFycmF5KCg2ICogbikgPj4gMyk7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHBvcyA9IDAsIHdpZHRoID0gMCwgY2FycnkgPSAwOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjYXJyeSA9IChjYXJyeSA8PCA2KSB8IGxvb2t1cFtzLmNoYXJDb2RlQXQoaSldO1xyXG5cdFx0d2lkdGggKz0gNjtcclxuXHRcdGlmICh3aWR0aCA+PSA4KSB7XHJcblx0XHRcdHJldFtwb3MrK10gPSAoY2FycnkgPj4gKHdpZHRoIC09IDgpKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuLy8gZWcuIFswLDEsMiwzLi4uXSA9PiBbMCwtMSwxLC0yLC4uLl1cclxuZnVuY3Rpb24gc2lnbmVkKGkpIHsgXHJcblx0cmV0dXJuIChpICYgMSkgPyAofmkgPj4gMSkgOiAoaSA+PiAxKTtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9kZWx0YXMobiwgbmV4dCkge1xyXG5cdGxldCB2ID0gQXJyYXkobik7XHJcblx0Zm9yIChsZXQgaSA9IDAsIHggPSAwOyBpIDwgbjsgaSsrKSB2W2ldID0geCArPSBzaWduZWQobmV4dCgpKTtcclxuXHRyZXR1cm4gdjtcclxufVxyXG5cclxuLy8gWzEyM11bNV0gPT4gWzAgM10gWzEgMV0gWzAgMF1cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWQobmV4dCwgcHJldiA9IDApIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB4ID0gbmV4dCgpO1xyXG5cdFx0bGV0IG4gPSBuZXh0KCk7XHJcblx0XHRpZiAoIW4pIGJyZWFrO1xyXG5cdFx0cHJldiArPSB4O1xyXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdFx0cmV0LnB1c2gocHJldiArIGkpO1xyXG5cdFx0fVxyXG5cdFx0cHJldiArPSBuICsgMTtcclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVhZF9zb3J0ZWRfYXJyYXlzKG5leHQpIHtcclxuXHRyZXR1cm4gcmVhZF9hcnJheV93aGlsZSgoKSA9PiB7IFxyXG5cdFx0bGV0IHYgPSByZWFkX3NvcnRlZChuZXh0KTtcclxuXHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHY7XHJcblx0fSk7XHJcbn1cclxuXHJcbi8vIHJldHVybnMgbWFwIG9mIHggPT4geXNcclxuZnVuY3Rpb24gcmVhZF9tYXBwZWQobmV4dCkge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHcgPSBuZXh0KCk7XHJcblx0XHRpZiAodyA9PSAwKSBicmVhaztcclxuXHRcdHJldC5wdXNoKHJlYWRfbGluZWFyX3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0d2hpbGUgKHRydWUpIHtcclxuXHRcdGxldCB3ID0gbmV4dCgpIC0gMTtcclxuXHRcdGlmICh3IDwgMCkgYnJlYWs7XHJcblx0XHRyZXQucHVzaChyZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpKTtcclxuXHR9XHJcblx0cmV0dXJuIHJldC5mbGF0KCk7XHJcbn1cclxuXHJcbi8vIHJlYWQgdW50aWwgbmV4dCBpcyBmYWxzeVxyXG4vLyByZXR1cm4gYXJyYXkgb2YgcmVhZCB2YWx1ZXNcclxuZnVuY3Rpb24gcmVhZF9hcnJheV93aGlsZShuZXh0KSB7XHJcblx0bGV0IHYgPSBbXTtcclxuXHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0bGV0IHggPSBuZXh0KHYubGVuZ3RoKTtcclxuXHRcdGlmICgheCkgYnJlYWs7XHJcblx0XHR2LnB1c2goeCk7XHJcblx0fVxyXG5cdHJldHVybiB2O1xyXG59XHJcblxyXG4vLyByZWFkIHcgY29sdW1ucyBvZiBsZW5ndGggblxyXG4vLyByZXR1cm4gYXMgbiByb3dzIG9mIGxlbmd0aCB3XHJcbmZ1bmN0aW9uIHJlYWRfdHJhbnNwb3NlZChuLCB3LCBuZXh0KSB7XHJcblx0bGV0IG0gPSBBcnJheShuKS5maWxsKCkubWFwKCgpID0+IFtdKTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IHc7IGkrKykge1xyXG5cdFx0cmVhZF9kZWx0YXMobiwgbmV4dCkuZm9yRWFjaCgoeCwgaikgPT4gbVtqXS5wdXNoKHgpKTtcclxuXHR9XHJcblx0cmV0dXJuIG07XHJcbn1cclxuIFxyXG4vLyByZXR1cm5zIFtbeCwgeXNdLCBbeCtkeCwgeXMrZHldLCBbeCsyKmR4LCB5cysyKmR5XSwgLi4uXVxyXG4vLyB3aGVyZSBkeC9keSA9IHN0ZXBzLCBuID0gcnVuIHNpemUsIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX2xpbmVhcl90YWJsZSh3LCBuZXh0KSB7XHJcblx0bGV0IGR4ID0gMSArIG5leHQoKTtcclxuXHRsZXQgZHkgPSBuZXh0KCk7XHJcblx0bGV0IHZOID0gcmVhZF9hcnJheV93aGlsZShuZXh0KTtcclxuXHRsZXQgbSA9IHJlYWRfdHJhbnNwb3NlZCh2Ti5sZW5ndGgsIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0uZmxhdE1hcCgodiwgaSkgPT4ge1xyXG5cdFx0bGV0IFt4LCAuLi55c10gPSB2O1xyXG5cdFx0cmV0dXJuIEFycmF5KHZOW2ldKS5maWxsKCkubWFwKChfLCBqKSA9PiB7XHJcblx0XHRcdGxldCBqX2R5ID0gaiAqIGR5O1xyXG5cdFx0XHRyZXR1cm4gW3ggKyBqICogZHgsIHlzLm1hcCh5ID0+IHkgKyBqX2R5KV07XHJcblx0XHR9KTtcclxuXHR9KTtcclxufVxyXG5cclxuLy8gcmV0dXJuIFtbeCwgeXMuLi5dLCAuLi5dXHJcbi8vIHdoZXJlIHcgPSBsZW5ndGggb2YgeVxyXG5mdW5jdGlvbiByZWFkX3JlcGxhY2VtZW50X3RhYmxlKHcsIG5leHQpIHsgXHJcblx0bGV0IG4gPSAxICsgbmV4dCgpO1xyXG5cdGxldCBtID0gcmVhZF90cmFuc3Bvc2VkKG4sIDErdywgbmV4dCk7XHJcblx0cmV0dXJuIG0ubWFwKHYgPT4gW3ZbMF0sIHYuc2xpY2UoMSldKTtcclxufVxuXG4vLyBjcmVhdGVkIDIwMjMtMDItMjFUMDk6MTg6MTMuNTQ5WlxudmFyIHIkMSA9IHJlYWRfY29tcHJlc3NlZF9wYXlsb2FkKCdBRWdTYndqRURWWUJ5UUthQVFzQk9RRHBBVFFBbmdEVUFIc0FvQUJvQU5RQWFnQ05BRVFBaEFCTUFISUFPd0E5QUNzQU5nQW1BR0lBSGdBdkFDZ0FKd0FYQUMwQUdnQWpBQjhBTHdBVUFDa0FFZ0FlQUFrQUd3QVJBQmtBRmdBNUFDZ0FMUUFyQURjQUZRQXBBQkFBSGdBaUFCQUFHQUFlQUJNQUZ3QVhBQTBBRGdBV0FBOEFGQUFWQkZzRjFRRVhFMG8zeEFYVUFMSUFya0FCYUFDbUFnUEdBSzZBTURBd01BRS9xQVlLN1A0SFFBYmxNZ1ZZQlZrQVBTdzVBZmEzRWdmSndnQVBBOG1lTkFMR0NqQUNqcUlDaHRrL2oyK0tBc1hNQW9QekFTRGdDZ0R5cmdGQ0FpNk9Da0NRQU9RQTR3b1dBQmpWdXNrTkRENmVCQng0QVA0Q09oaStEK3dLQmlycUJnU0NhQTBjQnk0QXJBQnFrdSttbklBQVhBYVVKQWJxQUJ3QVBBeVVGdnlwL01vOElOQUl2Q29Ec2hROEFQY3ViS1FBb240WkFCZ0VKdGdYQVI0QXVobk9CUHNLSUUwNENaZ0ppUjhjVmxwTTVJTkRBQlFBRFFBV0FBOXNWUUFpQUE4QVNPOFcyVDMwT1ZuS2x1WXZDaEVlWDA1WlBlMEFGQUFOQUJZQUQyd2dYVUNZQU1Qc0FCd0FPZ3pHRnJ5cC9BSGF1UVZjQmVNQzBLQUN4TEVLVFIya1poUjBHbTVNOWdDOERtZ0M0Z0FNTGpTS0Y4cVNBb0Y4QVJNY0FMNE9hQUxpQUF3dUFVbFFKcEpNQ3dNdC9BVXBDdGhxR0s0QjJFUUFjaXdTZUFJeUZpSURLQ2k2T0d3QU91SUI5aVlBeUE3TXRnRWNaSUlBc2dZQUJnQ0sxRW9GSE5ac0dBQ29LTklCb2dBQUFBQUFLeTREbkFCb0FRb2FQdTQzZFFRWkdBQ3JBY2dDSWdEZ0xCSjBPdlJRc1RPaUtEVkpCZnNvQlZvRldiQzVCV283WGtJVE8xaENtSHVVWm1DaCtRd1VBOFlJSnZKNEpBU2tUQUpVVkFKMkhLd29BWkNrcGpaY0EwWVlCSVJpQ2dEU0JxeEFNQ1FIS2dJNlhnQnNBV0lnY2dDRUhob0FsZ0ZLdUFBb2FoZ0JzTVlET0M0aVJGUUJjRm9HWmdKbUFQSktHQU1xQWdZQVNrSUFyQUJlQUhRQUxMWUdDUFR3R282QUFBQUtJZ0FxQUxRY1NBSFNBZHdJRERLWGVZSHBBQXNBRWdBMUFENEFPVFIzZXRUQkVHQVFYUUpOQ2t4dE94VU1BcTBQcHd2bUVSWU0waXJNMDlrQU5Lb0g3QU5VQit3RFZBTlVCK3dIN0FOVUIrd0RWQU5VQTFRRFZCd0w4QnZVd1JCZ0Qwa0ViZ1dQQll3RTF3aUVKa29SZ2djcENOTlVEblFmSEVnRFJnRDlJeVpKSFR1VU13d2xRMHdOVFFRSC9UWkRiS2g5T1FOSU1heFU5cENqQTh3eVVEbHRBaDV5RXFFQUt3OTBIVFcyVG45NlNIR2hDa3hQcjdXQVNXTk9hQUsvT3FrLytRb2lDWlJ2dkhkUEJqNFFHQ2VpRVBRTU1BR3lBVGdONmt2VkJPNEdPQVRHSDNvWkZnL0tsWmtJb2kzYURPb200QzZlZ0ZjajhpcUFCZXBMOFR6YUMwcFJaUTlXQzJJSjREcGdnVXNESGdFS0lvZ0syZzAyQ0dvUThBckdhQTNpRVVJSE5nUFNTWmNBb2diK0N3NGRNaFd5SmcxaXFRc0dPWFFHK0JyekM0d21yQk1tZXZrRjBCb2VCa29CSmhyOEFNd3U1SVd0V2k1Y0dVOWNCZ0FMSWlQRUZLVlFIUTBpUUxSNFJSb1lCeElscGdLT1EyMUtoRkV6SHBBaDh6dzZEV011RUZGNUIvSThBaGxNQzM0OG0wYW9SUXNSeno2S1BVVWlSa3dwQkRKOExDd25pQW5NRDRJTXRueHZBVllKSGdtdURHNFRMaEVVTjhJSU5nY1dLcGNoSnhJSUhrYVNZSmNFOUp3RDhCUE9Bd2dGUEFrK0J4QURzaHdxRXlzVkpnVUtnU0hVQXZBMjBpNndBb3hXZlFFVUJjZ1BJaC9jRUUxSDNRN21DSmdDWWdPQUplZ0FLaFVlQUJRaW1BaEFZQUJjajlWVEFpN0lDTVJxYVNOeEEyUVU1RjRSY0FlT0RsUUhwQnd3RmJ3YzNuREZYZ2lHQlNpZ3JBbFlBWElKbGdGY0JPQUlCalZZakowZ1BtZFFpMVVZbUNCZVFUeGQrUUl1REdJVm5FUzZoM1VDaUE5b0VoZ0JNZ0Z3QnpZTS9nSjBFZW9SYUJDU0NPaUdBVFd5TS9VNklnUk1JWUFnRGdva0EweHN5d3NrSnZZTTlXWUJvQkpmQXdrME9uZnJaNmhnc3lFWCtnY1dNc0pCWFNIdUM0OVB5Z3laR3I0WVAxUXJHZUVIdkFQd0d2QW41MEZVQmZ3RG9BQVFPa296NndTNkMyWUlpQWs4QUVZT29CUUgxQmhuQ202TXpRRXVpQUcwbGdOVWpvQUNiSXdHTkFjSUFHUUloQVYyNGdBYUFxUUlvQUFDQU13RFZBQTJBcW9IbWdBV0FJSStBVG9ESkN3Qkh1SUNqQU9RQ0M3SUFaSXNBZkFtQkJqQURCSUE5RFJ1UndMRHJnS0FaMmFmQmRwVkFvc0NSaklCU2lJRUFrdEVUZ09zYnQ0QTJBQklCaERjUkFFU3FFZklGK0JBQWR4c0tBREVBUGdBQWpJSEFqNEJ5Z0h3YWdDMEFWd0xMZ21mc0xJQlN1WW1BSUFBRW1nQjFBS0dBTm9BTWdCODdnRlFBRW9GVnZZRjBBSk1SZ0VPTGhVb1ZGNEJ1QU1jQVRBQkNnQjJCc2lLb3NZRUhBUnFCOUFDRUJnVjNnTHZLd2V5QXlMY0U4cEN3Z0s5MjFJQU1oTUtOUXFrQ3FOZ1dGMHdBeTV2UFUwQUN4K2xQc1EvU3dWT08xQTdWVHRRTzFVN1VEdFZPMUE3VlR0UU8xVURsTHpmdk44S2FWOUNZZWdNb3czUlJNVTZSaFBZWUU1Z0x4UEZMYlFVdmhYTEpWTVpPaHE1SndJbDRWVUdEd0V0MEdZdENDazBjaGU1QUR3cFpZTStZNE1lTFFwSUhPUlRqbFQxTFJnQXJrdWZNNndOcVJzU1JEMEZSSFhxWWljV0N3b2ZBbVIrQW1JL1dFcXNXRGNkQXFIMEFtaVZBbVlHQXArQk9CZ0lBbVk0QW1ZakJHc0VmQU4vRUFOK2p6a0RPWFFVT1g4NklDQUNiQm9DTWpNNEJ3SnR4QUp0cSt5SE1HUkNLQUZrQU5zQTNnQkhBZ2VWRElvQSt3aS9BQXF5QW5jc0FuYWZQQUo1U0VBQ2VMY2FXZGhGcTBid0FudzhBbnJGQW4wR0FuenRSLzFJZW1BaEFDZ1NTVlZLV0JJVVNza0MwUDRDME1sTEpBT0lUQU9INDBUQ2tTOEM4cDVkQUFNRHEwdkxUQ29pQU14TlNVMnNBb3M4QW9yVnZoZ0VHa0JrQXJRQ2pqUUNqbGs5bEg0Q2p0WUNqbGwxVWJGVE1nZFMwVlNDQXBQNEFwTUpBT1lBR1ZVYlZheFZ6UU1zR0NtU2d6TGVlR05GT0RZQ2w1d0M3NjlZSHFVQVZpSUNsb3dDbG5tWkFLWlpxVm9HZmtvQU9BS1dzZ0tXUzF4QlhNNENtY2dDbVdGY3gxMEVGZ0tjbURtL09wb0NuQk1DbjVnQ25yV0hBQm9NTGljTUFwM3VBcDZQQUxJNllURmg3QUtlMEFLZ2F3R21BcDZjSEFLZVM2Smp4V1FrSWlnQ0o2d0NKbnNDb1BnQ29FblVBcVlzQXFYTEFxZjhBSG9DcCs5b2VXaXVBQUJHYWhscXpnS3M0QUtzcXdLdFpBS3Mvd0pYR2dKVjJRS3gzdFFESDB0c2xBS3l1Z29Dc3VVVWJOMXRZRzFGWEFNbHlnSzJXVGc4Ym8wREtVSUN1RnNDdVVRU0Fya25kSEF6Y040Q3ZSWURMYThETWc0Q3ZvVngvd016YmdLK0YzTWZjMHdDdzhnQ3d3RnpmM1JJTWtKMDNRTThwQU04bHdNOXZBTEZlUUxHUkFMR0RZWUN5R1pPQXNoQkFzbE1Bc2tyQW1TYUF0M1BlSFplZUt0NUlrdk5BeGlnWnY4Q1lmRVo4SlVoZXdoZWoxNjREZ0xQYUFMUGFTeElVTS93RUp3QXc2b0N6M0FCSnVjRFRnOStTQUlDM0NRQzI0Y0Mwa3dEVWxrRFUxd0EvZ05WaVlDR1BNZ1Q2bDFDY29MTGc0b0Myc1FDMmR1RURZUkdwemtEaHFJQUxBTmtDNFp1VnZZQVVnTGZZZ0xldFhCMEF1SXM3UkVCOHkwa0FmU1lBZkxQaEFMcjhBTHBiWFlDNnZZQzZ1RUE5a1FCdGdMdWhnTHJtWmFubHdBQzdqd0RoZDJZZG5EZGNaNEM4d0FBWmdPT0U1bVFBdmNRQTVGckE1S0VBdmVWQXZuV0F2aGptaG1hcUxnMG14c0RuWUFDL3ZjQkdBQTJueG1mc0FNRmlnT21ad09tMWdET3dnTUdaNkdGb2dJR0F3eEdBUXdCSEFkcUJsNjJaQUlBdUFSb3ZBNklIckFLQUJSeU5nQWdBekFTU2dPR2ZBRmdKQjRBak93QUhnRG1vQVNjamdpMEJoeWd3Z0NvQlJLODZoNCtQeFo1QldrNFAwRXNRaUpDdFY5eUVsKzlBSmJHQlRNQWtFMGFtN283SjJBekVyclFEakFZeHhpS3lmY0ZXQVZaQlZnRldRVmtCVmtGV0FWWkJWZ0ZXUVZZQlZrRldBVlpSeFlJMklab0F3TURDbVZlNml3RXlnT3lCakM4dkFDOEJLaThBT2hCS2hhekJVYythajV4UWtCQ3QxOTJPRi9wQUZnU002d0FqUC9NYk12OXB1aEdlejRuSkFVc0Z5ZzNObjV1MzJ2QjhobkRMR29CYk5kdk1SZ0ZZQVZyeWNMSnVRalFTbHdCQVFFS2ZWNStqTDhBTkQrQ0FBUVcwZ2JtcmlRR0FJekVEQU1DRGdEbFpoNCtKU0JMUXJKQ3ZVSTVKRjhvWURjb09TUUp3ajRLUlQ5RVBuaytnajV4UG5JQ2lrSzlTa004WDh4UFVHdE9DeTFzVlRCckRHOGdYK0UwT3h3SmFKd0tZeVFzUFI0blFxeEN2U3pNQXN2OVg4b1BJQzhLQ1FvQUFDTitudDlyT3k1TEdNbXN5YTBKWnNMTXpRcGhRV0FQNWhDa0VnQ1RqaDVHUWlZYnFtMDZ6amtLTkQ5RVBuRkNRQndJQ3g1TlNHMWNMUzVhNHJ3VENuN3VIaXhDUUJ4ZUNVc0tEelJWUkVNNEJUdEVuQzBLZ2h3dVFrQWI5Z2xVSXlRWk1USUJCbzlpOEY4S2NtVEtZQXhnTGlSdkFFUmdHam9ESEI5Z3RBY0RiQkZtVDJCT0VnSUFaT2hnRm1DV1lINWd0R0JNWUpKcEZoZ0d0Zy9jVnFxOFd3dERGNndCdkN6T3dnTWdGZ0VkQkI4QmVnSnRNREdXVTRFQml3cTVTQnNBNVNSMGp3dkxEcWRONndHY0FvaWRVQVZCWUFENEFENExBVFVYV0hzTXBnMGxJTHV3U0FCUURUVUFGaE80TlZVQzB3eExaaEVjQU5sUEJuWUVDeDliQURJQXR3S2JLQXNXY0t3ek9hQWFBVndCaHduOUE5cnVFQWFyQmtzR3VnQWV5MWFxV3dxN1loT0tDeTFBRHJ3QnZBRWpBMGhiS1NrcElSOGdJaTBUSndjaURZNEFWUUp2V0pGS2xnSnZJQTl5U0FIVWRSRFBVaUVhcXJGTjZ3Y1NCVTFnQVBnQVBnc0Jld0FISlcwTGlBeW1PVEV1eUxCWERnd0FZTDBNQUdSS2FGQWlJaHpBQURJQXR3S2JLQzA4RDg4Q2tSaDhVTHhZeVhSemp0aWxuQTcybWhVK0crMFMyaElIRHh3QnlBazdFSlFHRVN3Tk53d0FQQUMwendFREFLVUE0Z0NiaXpBQUZRQmNHOGN2YlhjckRzSVJBendsUk5UaUhSOE1HMzRDZkFUQ0M2dnhiUUE0T2k0T3B6a3V6NklkQjd3S0FCQTdMczhTR2dCOXJOc2REN3diU0J6T29uY2ZBVDRxWUIwQzdLQUpCRTN6NVI5bURMME0rd2c5Q2o4QUJjRUxQZ0pNRGJ3SXZRMDlDVDBLdlM3UG9pc092QWFZQWh3UGpCcmlCQndMdkJZOEFLRUxQQkM4QlJpaGU5MEFPMndNUFFBQ3B3bTlCUnpSOVFZRkIyL0xCbndBQjd3U1hCSVN2UUVDQU9zQ0FBQjFGVndIRnN3Vi9IQVh2Qmc4QUM2OEF1eW92QUFldkFKV0lTdUFBQUc4QUFMa0ZUMFZ2Q3Zzbzd6SnFEd0VBcDhuVEFBQ1hBRG4zaG04Q2FWY0Q3L0ZBUFVhZkFpaUJRdi9jUURmdktlOEdOd2F2S09NZVhNRy9LbWNoQUFTdkFjYkRBQURsQUJ0dkFjQUM3eW5QQUlhUExzSW9wekxEdndId2FrOEFPRjhMN2R0dndOSkFBUHNBQlc4QUFiOEFBbThBR21NQUJxOEFBNjhBeGk4am1vVi9BQUJYQUFPYkFBdVRCOEFCcndBRjd3SUlnQU5Td0M2dkNjQUE3d0FEcHdxN0FDeVd3QWNIQUFidkFBQjdBcWlBQVhIQ3hZVjNBQUhuQUJDdkFFREFHbThBQXQ4QUIyOEFBaThDYUlBQmNzQWJxQVoxZ0NTQ0NJQUJjc0FBVHdBQjl3QUhad0lJZ0FHbXdBSmZBQWJMQUJ0SEFEbXZJRUFDRndBQ0R3QUZMd0FhUHdKSWdBR3l3RGpqQUFKUEF1aURzWDdZQUFIUEFCdW5VQkpBRWdBQ3J3RkFBTThBQW11QXpnQUJ4d0FHWHdBQWd5bS9BQUtIQUFLUEFBSi9LZnNCcndBQ1J3QUF3d0FFRHdCQUJROEFCRnNBQStNQUEzc0FBMjhBQmtNQnhZY0FCVThBRzZjRnJRQnZBQzdBQk04QkFCcExBc0E0VXdBQWp3QUJGTUFGM3dGSEFBRzBRQVl2QjhCZkNsVEFEcEdBTEFKQnc0TWN3QXBLM0VCcFFZSVh3SnRKQTBBQ2dod1RHMWdLNG9nZ1JWakxqY0RvZ3ExQUFMWkFCY0MvQVJ2QVhkelNGTVZJZ05RQWhZL0FTMEdCSFJIdm54VGUwRUFLZ0F5QXZ3QVZBdmNBSHlSTFFFc0FIZm1EaEl6UndKTEFGZ0dBQUpSQVFpTHpRQjVQQVFocGdCYkFOY1dBSlpwT0NDTUFNNXNzZ0RRMVJjSnczWjBIQmxYSGdyU0FZbVJyQ05VVkU1SkV6M0Rpdm9BZ0IwNFFTb3M0UktZVUFCekFTb3NNU2xER2hBRE1WWUUrTWJ2QUV4bTNRQnJBbklDUUJGN09zaDRMelhXQmhFVElBVVZDSzZ2L3hQTkFDWUFBUUliQUlZQWlRQ09OZ0RqQUxRQTFRQ2RQUUM3QUtzQXBnQ2hBT2NBbndEVEFKd0E0QUVCQVB3QXdBQjZBRnNBeXdETkFQd0Exd0RyQUlrQW9nRXFBT01BMkFEVkJBSUlLelRUMDlQVHRiL2J6TS9OUWpFV0FVc0JWUzVHQVZNQllnRmhBVlFCUlVwQ1JHY01BVXdVQmdrRU16Y01Cd0FnRFNRbUtDczNPVGs4UER3OVBnMC9IVkJRVUZCU1VsRlNLRk5VVmxWVkhGeGdZRjloWUNObFoyOXVjWEZ4Y1hGeGMzTnpjM056YzNOemMzTjFkWFoxZEZzQVBlc0FRZ0NUQUhFQUt3QmY4UUNIQUZBQVVBQXdBbS9vQUlUKzhmRUFYUUNNNndDWUFFZ0FXd0JkK1BpcEFINEFmZ0JpQUU4QXFnQWRBSzhBZkFJNUFqd0E5UURnQVBjQTl3RGhBUGdBNGdEaUFPRUEzd0FvQW5RQlNnRTVBVGNCVFFFM0FUY0JOd0V5QVRFQk1RRXhBUlVCVVJBQUtna0JBRXdZQ3hjRUZoY1BBSWNBandDZkFFb0FZeGtDS2dCdkFHZ0FrQU1PQXlBckF4cENQMGdxQUlvQ1NBREFBbEFDblFDNUFvOENqd0tQQW84Q2p3S1BBb1FDandLUEFvOENqd0tQQW84Q2pnS09BcEVDbVFLUUFvOENqd0tOQW8wQ2pRS05Bb3NDamdKdUFjMENrQUtZQW84Q2p3S09GM29NQVBjR0E1Z0NXZ0l6R0FGTkVUWUMyeElMTEJRQlJ6Z1VUcElCZEtVOUFXSmFBUDRET2tnQS93Q1NLaDRaa0dzQUttRUFhZ0F2QUlvRGxjeU04SytGV3dhN0xBL0RFZ0tlMW5VckN3UWtXd0d6QU41L2dZQi9nWCtDZzROL2hJZUZmNGFKaDRHSWc0bURpbitMZjR4L2pZdU9mNDkva0lPUmY1Si9rMytVZjVXRWxvbVhnNWgvQUlNbG9RQ0VCRHdFT1FRN0JENEVQQVJDQkQ4RU9nUkFCRUlFUVFROUJEOEVRZ0NrQTRnQXlsSUEwQUlOQVBkYkFQY0JHZ0QzQVBVQTlRRDJBUFhWaFNSbXZ3RDNBUFVBOVFEMkFQVWRBSXBiQVBjQWlnRWFBUGNBaWdMdEFQY0FpdFdGSkdhL0hRRDRXd0VhQVBjQTl3RDFBUFVBOWdEMUFQZ0E5UUQxQVBZQTlkV0ZKR2EvSFFDS1d3RWFBUGNBaWdEM0FJb0M3UUQzQUlyVmhTUm12eDBDUkFFM0Frc0JPZ0pNd2dPZkF1MERuOVdGSkdhL0hRQ0tXd0VhQTU4QWlnT2ZBSW9DN1FPZkFJclZoU1JtdngwRU1RQ0tCRElBaWdlT01tNGhMUUNLQVQ5dkJDUUEvZ0RIV3dNQVZWdi9GRE1EQUlvRFB0a0FTZ01BaWdNQWwyZEJ0di9UcmZMemFrYVBoM2F6dG1JdVpRclIzRVIybjVZbytxTlIyaksvYVAvVjA0VUsxbmpJSlhMZ2thYjlQak94eUpEVmJJTjNSL0ZaTG9aVmwya1lGUUlaN1Y2THBScUdEdDlPZERvaG5KS3A1eVgvSExqMHZvUHBMcm5lRGFOMTF0NVczc1NNNEFMc2NnU3c4ZnlXTFZrS2EvY05jUW1qWU9nVExaVWdPTGkyRjA1ZzRUUjBSZmdaNFBCZG50eGRWM3F2ZHhRdDhEZWFNTWdqSk1nd1V4WU4zdFVOcFVOeDIxQXZ3QUREQUlhMCtyYVRXYW9CWG1TaEFsNUFUaHBNaTI4Mm8rV3pPS01seGpIajdhK0RJNkFNNlZJOXcreHloM0V5Zy8xWHZQbWJxamVnMk1HWHVnSHQ4d1cwM0RRTVJUZDVpcXFPaGpMdnlPQ2NLdFZpR3dBSFZMeWw4NktxdnhWWDdNeFNXOEhMcTZLQ3JMcEI4U3NwQU9ITzlJdU93Q2g5cG9Mb01FaGE5Q0hDeGxSQVhKTkRvYmR1Y1dqcWhGSHFDa3pqVE0yVjlDSHNsd3E0aVUxOUl4cWhJRlpNdmUxNWxEVGlNVlpJUGRBRFhHeFRxelNUdjBkRFd5azFodDQzMHl2YVlDeTlxWTBNUTNjQzVjMXV3NG1IY1RHa01IVEFHQzk5VGtOWEZBaUxRZ3c5Wldod0tKakdDZStKNUZJYU1wWWhoeVVuRWdmckYzekV0em40MERkZ0NJSlVKZlowbW8zZVhzRHduZUo4QVlDcjdWeDJlSEZudDJINlpFeUFIczlKb1E0THpoNXpCb0dPR3dBejM3Tk9QdXFTTm1aZjUxaEJFb3Z0cG0yVDF3STc5T0JXRHl2Q0ZZa09OcUFLR1ZZZ0lMMEYrdXhUY01MU1B0RmJpTkRiQlBGZ2lwOE1HRG1MTEhiU3lHWGRDTU82Zjd0ZWlXOUVFbW9yWis3NUt6YW5ad3ZVeVNnam9VUUJUZkhsT0llckpzNlk5d0xsZ0R3MThBQjFuZTB0WlJOZ0dqY3JxSGJ0dWJTVW9vRXB5NGhXcER6VFNybXZxdzBIOUFvWFFMb2xNdDllT00rbDlSaXRCQjFPQm5yZEMxWEw0eUxGeVhxWlNnWmh2N0ZubkRFWExVZWZmYjRuVkRxWVRMWTZYN2dIVmFLNFpabGVwamEyT2U2T2hMREkvVmU1U1FUQ21KZEgzSEplYjE0Y3c5OVhzQlFBbER5NXM1a2lsMnNHZXpaQTN0Rm9rMklzTmphN1F1RmdNMzBIZmYzTkdTc1NWRllaTE9jVEJPdmxQeDh2TGhqSnJTSTd4ck5NQS9CT3pwQklKcmRSMSt2K3p3NFJaN3J5NmFxNC90RmZ2UFF4UUNQRHNYbGNSdklaWWwrRTVnM2tKK3pMTVpvbjB5RWxCdkVPUVRoNlNhQWRJTzZCd2RxSnFmdmdVK2U4WTY1RlFoZGlIa1pNVnQ5LzM5TjJqR2QyNko2Y05qcThjUUl5cDZSb25SUGdWbjJmbDg5dVJEY1EyN0dhY2FOME1QcmNOeVJsYlVXZWxLZkRmeXJOVlZHQkc1c2pkM2pYelR4MDZ5d3l6dVduNWpidkVmUFBDVGJwQ2xrZ0V1OW9QTEtJQ3hVNUh1RGUzakExWG52VTg1SVlZaGFFdE9VMVlWV1loRUZzYTQvVFFqM3JIZHNVMmRhMmVWYkY4WWpTSTBtNjE5LzhiTE1adTN4aWxkd3FNN3pmMWNqbjRXaHgwUFNZWGNZNWJSN3dFUWZHQzdDVE9Yd1pkbXNkVE84cTN1R203UmgvUmZDV3dwekJIQ0FhVmZqeGdpYkw1dlVlTDBwSDZiekRtSTl5Q1hLQy9va2ttYmMyOE9Kdkk4N0wvYmpGenBxMERIZXB3NGtUMU9kK2ZMN2N5dUZhUmdmYVVXQjIrK1RDRnZ6MTFKMGxlRXRyR2twY2NmWDl6MkxZMzlzcGg0UEJIQ2pOT09rZDB5YlVtK1p6UzhHa0ZicU1wcTh1aVgyeUhwYTBqbGxUTGZHVERCTVlSNkZUNUZXTExEUE1rWXh0MVEwZXlNdnhKV3p0RGp5MG02VnZaUHZhbXJGWGpIbVBwVTZXeHJacUg2V1cvL0kzN1J3dnFQUWhQejhJM1JQdVhBazFDOTRacHJRV205aUdNL0tnaUdETzZTVjlzanArSm1rNFRCYWpNTko1enpXWjFrMWpydGVRUUJwOUMyZE92bWJJZWVFTUU4eTU3M1E4VGdHZStaQ3p1dE00NWdZTEJ6WW0yTE52Z3Eya2ViQWJNcEhSRFN5aDZkUTI3R2JzQUFkQ3FRVlZYV0MxQyt6cHdCTTJMcjRlcXRvYm1tdTF2SkVEbElRUjFpTjhDVVdwenRxNTB6N0ZGUUJuM1NLVmlYNndTcXpWUUNvWXZBakJ5amVTYStoMVBSbllXdkJpblREQjljSHQ0ZXFEc1BTNGpjRDNGd1hKS1QwUlFzbDhFdnNsSTJTRmF6Mk90bVlMRlY4Rndndldyb1ozZkttaDdidGV3WDl0ZkwydXBYc3JzcXBMSnpwek5HeU5sbnVaeWV0ZzdESU94UVRNQlI3ZHFsclRsWjZGV2kxZzRqMU5TakEyajFZZDdmelRINms5THhDeVVDbmVBS1lDVTU4MWJudktpaDZLSlRlVGVDWDRaaG1lL1FJejd3Mm8rQWRTZ3RMQWtkckxTOW5md2VZRXFyTUxzckdHU1dYdGdXYW1BV3A2K3g2R00vWjhqTnczQnFQTlEzOWhyellMRUNuM3RQdmgvTHFLYlJTQ2lER2F1REtCQmova0dicG5NMUJiL215OGh2NE5XU3RjbGt3amZsNTd5NG9ORGd3MUpBRzlWT3RpM1FWVm9TemlNRXNTZGZFamFDUElEYjdTZ3BMWHlrUXNNK25icWJ0OTdJMG1JbHpXdjB1cUZvYkxNQXE4UmQ5cHN6VUJLeEZoQlB3T2pmLy9nVk96MnI3VVJKMk9ucHZpQ1h2OWl6M2E0WC9ZTEJZYlhvWXd4QnYvS3EwYTVzNHV0UUh6b1Rlcko3UG1GVy9uby9aQXNpZC9oUklWODJ0RCtRYWJoNUYxc3NJTThSaTNjaHUwUHVQRDNzU0pSTWpEb3hMQWJ3VWJyb2lQQXovVjUyZThzM0RJaXh4bE83T3J2aE1qM3FmekEwa0t4endpY3I1d0ptWndKeFRYZ3J3WXNxaFJ2cGdDMk5mZHlkK1RZWXhKU1pnaytnazJnOUt5SFNsd1FWQXlQdFdXZ3ZWR3lWQnFzVTJMcERsTE5vc1NBdG9sQzF1Qkt0NXBRWkxoQXhUamVHQ1dJQy9IVnBhZ2M1clJ3a2dwQ0hLRXNqQThkK3NjcDhhaU1ld3dRQmhwNWRZVFY1dC9OdmwrSGJETXU4RjNTMHBzUHlaYjFiU25xbEhQRlVuTVFlUXFTcXdEQlQyM2ZKTzlnTzNhVmFhMWljclhVMFBLd2xNTTVLK2lMM0FUY1ZxMmZGV0trMGlyQ1RGNExEVkRHNGdVcGt5cGxxNmVmY1pTK1dEUjF3b0FwakQxOHgrMkpRUjlvT1h6dUE3dXk0YisvOTFXc0pkL3RTZDFRY0FIOFBWUFhBcGllQTM3QjdZWFBoRFBIMWF6UDNQS1IrSGZIbU9vRFlMZXVLc0lpL3NzU3NkWXM2MnFKbzE0SHcxUDJOLzZ6cHI4RjNGVFdtSjR5c0FWY2w4NEl2L3RsLy8vWjhGYUFXYkJRYnlNTkRaanJaMkp3ZFJqdGQxak9lTnVtU29kRnRyNC9aZjQ1aVJKZi84SFNXK0tJQi8rR2xLdThSdjFCUExyLzRkdW9MK2tGUFJxcnN0RXI0MWdmSnVwb0pSZjRoY1lEV1g5M0ZPY2ZFQmlJaXZ4dGp0VjhnN212T1JlaWFtWVdLRTd2ZlBidjN2Mkw5S3dxM2NJREZHTHloeWZPR3VmLzl2QTVtdUg2UGpnN0I0U1VqMnlkRFhyYTlmU0JJK0Ryc05IQTZsNTF3Zkhzc0piKzExVGZOazdCOE9sZVVlM1krWm1IYm9NRkhkdjdGRlAyY2ZJU0Z5ZUFRUjBzay9YdjYySEJUZFc0SG1uR1NMRmsvY3F5V1ZWRkprZElJYSs0aG9zM0pSSGNxTG9SS001aDJRdGsxUlp0eklTTXRsWFRmVHFJYzc3WXNDQ2dRRDByNjFqdHhza0NjdHdKT3RqRS9wTDh3QzRMQkQ0QVpGamgyd3p6RkNyVC9QTnFXMC9EZUJia2ZNZnpWbTl5eTA2V2lGKzFtVGROTkVBeXRWdG9oQktnM2JyV2QyVlFhK2FGK2NRMG1XNUN2YndPbFdDVDA3bGlYMjI2UGppVkx3RkNScy9BeDIvdStaTlBqck5GSVdJUGY1R2pIeVVLcDYwT2VYZTlGMDFmN0lhUGYvU0RUdnlEQWY3TFNXV2VqdGlaY3NxdFdaanJkbjZBMk1xQnduU2VLaHJaT2xVTW1nTWlvbm1pQ0l2WHFLWmZtaEdaMU13RDN1TUY0bjlLSmNmV0xBM2NMNXBxNDh0bTVORFlOaDNTUy9US1V0bUZTbFFSODlNUjQra3hjcUpncEdiaG05Z1huZURFTGt5cUFONW5pdG1JelRzY0tlSlJYcWQ2NFJpYU9BTFIyZDI5NU5Xd2JqSFJORzJBVTVvUjlPUzJvSmcvNUNZNkJGUGMxSnZEMk14ZGhwMi9NWmRJOGRMZVB4aVA0S1JJcDhWWG1xZmcranFkL1JORzdHTnVxMVUyU2lJNDczNUJkYzBNVkZ4Nm1INVVPV0VhNUh1aFl5a2Q2dDRNMWdZTFZTOG0xQis5YlVxaTVEemlRcTdxVDhkOTRjeEI2QUI0V3FNQ09GL3pQUHRSU1pVVWFNU3N2SE9XeEdBU3VmeXdUWDhvZ3k2SGdVZjlwK1ozMHdVRW9zbDhxZ213bTZvMkFWNm5POUhLUWpSSHBONlNVZWdJNXB2UjYxUkxuVUoxbHFDdG1mY3NSUXV0RWl6VnBBYVBYTjd4TXA1VVE1T1NaSzZ0bmlDSzlDcHlNZDdMalI2K014Zm9NRURQcFdkZjJwMm01TjNLTzRRTXhmK1Y3dkdkWWplbVFjelErbTJNR0lrRk5ZRE1mMFlvcDJlU3g4MXNQMzZXSFVjenFFaEt5c3AyaUpTWUF2ZmdKamluS3dUb1B2UktiK0hCaSs3Y0o5NlM1bmdmTE9YYUhBRlJMa3VsbzRUblhURk81MWdYMFRDQ280WlVIZGJwZGdrTUV3VVpBUGpoNk0raEE4RHp5Y2J0eEFnSDN1RDZpMG5OMWFUaUl1UTRCWUNFOWRFSEh3QW1JTlUrNFlFV3g0RUMzT1p3RkdmWVpNUExTY1ZsYitCQUFKZUFSVWgrZ2RXQTMvZ1JxQ3JmMWplY2dxZUZmMU1kenJyUDRTVmxHbTVtTWloU1ArellZa3NBQjdPK1NCUHdOUXFTTk1pTG5rdmlZL2tsd2djUm12cXRDcWVXZUEwZ2p1aXI0Q01acW13L250UDZNK2wwcGROOC9QOXhJNTNhUDd4L3phdkpiYktPejhWek8vblh4SXIxdGpwYXJNbnFkNmlXZEJ5SEt3NGxGNHAvdTU3WXYwN1dlWlBEblJsN3dnbURWWlo0NGZRc2pkWU8vZ21YUSs5NDBQUkdzdDhVTVFBcEZDNE9PVjIyZTROK2xWT1B5RkxBT2o0dDhSM1BGdy9GamJTV3kwRUx1QUZSZU5rZWU4T1JjQk9UMk5QRGNzN09mcFVtenZuL0Y5Q3prOW85bmFNeVZZeS9qOEk1cVZGbVFERmNwdEJwNjVKLytzSkEzdy9qNnkvZXFVa0t4VHNmMENaanROZFJTQkVtSjJ0bWZnbUpicXBjc1NhZ2srVWw5cWR5VitObnFGQklKWkZDQjFYd1B2V0dEQk9qVlVtcFdHSHNXQTV1RHVNZ0xVTktaNHZscTVxZnpZMUxuUmhDYy9taDUvRVgraHp1R2REeTVhWVl4NEJBZHdUVGVaSGNacGwzWDBZeXV4WkZXTkU2d0ZOcHBZczNMY0ZKZVBPeWZLWjhLWWI3ZG1SeXZET2NPUkxQSDBzeXRDNm1IMVVTM0pWajZwYVlNMUdFcitDVW15SFJuYWJIUHFMbGg2S2wwL0JXZDNlYnppRGZ2cFJRcFBvUjdOK0xrVWVZV3RRNlJuNXY1K050TmVCUHMyK0RLRGx6RVZSNWFZYlRWUHJaZWtKc1o5VUM5cXRWY1A5OXRoVkl0MUdSRW5OOHpYUDhtQmZ6Uyt3S1l5bThmY1c2S3FyRTcwMlpjbytoRlFBRUlSN3FpbW83ZGQ3d084QjdSK1FaUFR1Q1dtMVVBd2JsRFR5VVJTYmQ4NVA0UHord0JwUXlHUGVFcHNFdnh4SVprS3N5ZlNPVWNmRTNVcXpNRndaS1lpamI3c09renBvdSt0QzRiUFhleTVHSTFHVUFnOWMzdkx3SXdBaGNkUEhSc1l2cEFmemtaSFdZMjB2V3h4Sk8wbHZLZmo2c0cyZy9wSjF2ZC9YMkVCWmt5RWpMTjRuVVpPcE9PN01ld3lIQ3J4UUs4ZDVhRjdyQ2VRbEZYK1hrc0s2bDZ6OTcxQlB1SnF3ZGpqNjhVTE9qOVpURGRPTG9wTWRPTEwwUEZTUzc5MlNYRS9FQzlFRG5JWFpHWWhyNTJhUWIrOWIyekVkQlNucGt4QWRCVWt3SkRxR0NwWmsvSGtSaWRqZHAwekt2L0NtNTJFZW5tZmVLWDZIa0xVSmdNYlRUeHhJWmtJZUwvNnh1QWFBQUhiQTdtT05WZHVUSE5YL1VKajFuSkVhSTdmM0hsVXlpcUtuN1ZmQkUrYmRiNEhXbG4xSFBKeDAwMVVscTF0T3hGZjhXWkVBUnZxNURhMStwRTdmUFZ4TG50R0FDejNua29Mc0tjUGRVcWRDd3dpeVdrbVhUZDUrYnYzajdIYVJlUnQzRVNuNzgzRXczU1dzdmtFakt0Ym9jTmtzYnJMbVYrR1ZabjErVW5lbzM1TVQxLzRyOGZuZ1FYNS9wdE9SZmdtV2ZGNktTQi9zc0ptVVNpalh4UXFVcHprQU5Fa1NrWWdZajU2ME9PakpyNnVxY2tGdU8xNVRSTmdBQkV3TkRqdXMxVjNxMmh1TFBZRVJNQ0xYVU5tSkpwYk1yVVFzU083UW54dGE1NVR2UFdMNmdXbU1PdkZrbnFFVHpxekZWTzhTVmtvdkVkWWF0eXBMR21EeTlWV2ZnQWMwS3lJQ2hpT2hiZDdVbGJBZVZMUFp5RURwNFBPWEtCd04vS1A1cFQ2Q3lxczZ5YUkwMHZYTW4xdWJrOU9XVDlRL08ydC9DMjVxbG5PL3pPMHhjQnpwTUJDQUI4dnNkc2gzVThmblBYMVhsUEVXZmFZSnhLVmFUVWdmQ0VTV2w0Q0NrSXlqRTZpUTVKRmN3VTZTNC9JSDAvQWdhY3A4ZDVHenEyK0d6UG5KNytzcWs0MG1mRlFwS3JEYkFLd0xscjNPTkVhdGkyay95Y0xNU1V1N1YvN0JCa0RsTnlYb045dHZxWENiYk1jNFNTUVhnQy9EQlVZOVFqdHJDdFErc3VzRW9tQ3E4eGNOSk5OTVdDSDMxR3RsVHcyQmRDWGtKQmpUKy9RTldsQld3UTVTV0NoMUxkUTk5UVZpaS9EeVR4alNSNnJtZGFwM2wzTDNhaXBsUXBQWWxyek5tOWVyODhmWGQyK2FvK1lkVU5qdHFteGlWeG15WVB6SnhsNjdPb2tEY1RlekVHcWxka0dnUGJSZFhBK2ZHY3VaVmtlbWJaQnlvN0oxZE1ua0dOand3Q255K0ZOY1ZjV3ZXWUw5bWc4b0Y3akFDVldJM2JBNjRFWHBkTThiU0lFVklBczVKSkgrTEhYZ25Dc2djTUdQWnlBQVZCbmN2YkxpZXh6ZzlZb3pjeXRqUFhWbEFiUUFDN1RjNFMwQzhRTjRMbEFHamo0cFFBVldyd2thRG9VWUd4eHZrQ1dLUlJIa2R6SkI1enBSRWxlQkRMMW9ES0V2QXFta0RpYlZDNGtUcUY4OVlPNmxhVWpndEpQZWJCZnpyMTZ0ZzR0MTBHbU4xc0o1dmV6azJzVU9xOGJsQ241bVBaeVQzbHRhRGNkZEt1cFFqcXVzTk05d3RGVkQwQUJ6djE3ZlpEbjdHUFQxbmtDdGRjZ1llamNLMXFPY1RHdFB4bkNYMXJFckVqVldDbkVKdjVIYU9BVWpncGlLUWpVS2tRaTY0RDVnMkNPZ3dhczhGY2dJbDBQdzk1SDlkV3hFM1FHMFZiTU5mZmg2QlBsQW9qTERmNGVzMi81WGZxN2h3NU5HY09OMmc4UXN5MlVRbTk0S2RkS3l5M2tkSnhXZ3BOYUVjMTV4Y3lsYkxDM3ZuVDI2dThxUzkwcWMyTVU4TGRPSmM1VlBGNUtuU3BYSWhuajFlSkovanN6alowMW9SNkpERkpSb2VUUE8vd2g0SVBGYmRHOUtsanVTemV1STkycDhKRi9icGdERTh3Rzg2L1cyRUJLZ1BybXpkTGlqeHNzUW44bU00NGt5L0tMR09KY3JTd1hJcFphL1ozdjdXNkhDUms3ZXdkczk5TFRzVVcxTGJlSnl0dzhRL0JGWlZaeWZPOUJVSE9DZTJzdXVFa084RFU0ZkxYMElRU1EyVGRPa0tYRHRQZjNzTlY5dFloWUZ1ZXVQUmhmUWxFRXkrYVlNL01DejdkaURObUZTc3dZWWxaWlBtS3IyUTVBeExzU1ZFcXFCdG42aFZsMUJDRk9GRXhucW5Jc215WS9OQThqWG5EYU56cjdadjNodStJMU1mL1BKamswZ0FMTjJHOEFCemRmOUZOdldIdlpIaHY2eElvRENYZjk2NE14RzkydkdadHgvTFlVNVBlWnFnbHk4dFQ1dEdlUUdlSnpNTXNKYzVwK2E1Um4yUHRFaGlSem8vNU93ankxbjBMengzZXY4R0hRbWVXYjh2YWdHNk81UWs1bnJadVFUaUtPREk0VXFMMExMQXVzUzJWZTdqMUl2ZHhxdXUxQlI5UmM0UWtPaVVQd1FYSnY2ZHUyRThpNXBEaFZvUXBVaHlNV0dVVDJPMllPREloakFmSTcxZ3hlcDVyNXpBWTdHQlVacHk1MWhBdzBwY0NDcmhPbVU4V3A2dWpRVGRaUXNDanRxNlNIWDhRQU1OaVBDSUlrb3hoSEVaUGdzQmNPbFA0YUVySlpQaEY3cXZ4NmdIcm44aEV3UHdZYng4WW1UL243bGJjbVRpcDF2OGtnc3JJakZUQWx2TFk0TnVpbDBLRG1nejNzdllzMFpKM08zSXMvdlN4NHhweEYxZTJWQXRaRThkSnhHWUVJaENTdVB2Q2pQNTRsL05TTkRud2xLdkFXOG1HK0FRa2dwN2E4N0lnaDI2dUtNRkdEMFBvUEhUU3ZvV3hpSHVrK3N1OFhrUWlISWplWUtsL1JkY09IcHhoUUgzekhDTkUzYUFSbTgzQmw2ekd4VS92TWx0bFZQUWh1YmNxaFc0UllrbDZ1WGs1SmRQL1FwemFLRnB3Mk04enZ5c3YycWo3eGFRRUN1dTJha00wQ3Nzai91Qjkrd0RSN3VBNlhPbkxOYW9jemFsSG9NajMzZWlpdStEUmFGc1VtbG1VWnVoOWJqRFk0SU5NTlNTQWl2U2gwM3VKdm55NEdqK0QrbmV1ZG9hN2lKaTdjNFZGbFovSjVnVVI4MjMwOHpTTkF0L1pyb0JYRFd3MGZWM2VWUEFuM2FYMG10SmFiRjZSc1VabUwrRWhuK3duNTEvNFFpcE1qRCs2eTY0dDdiakw2YmpFTmFuMnByUTRoNysraEJKOU5Ydlg4Q1VvY0pxTUM5MzdJYXNMem01SzBxd1hlRk1BaW1NSGtFSVFJUUkyTHJROXNMQmZYdXlwNjZ6V3Zsc2g3NEdQdjdYcGFiajk5M3BSTk5EdUZ1ZDVvSWNuLzkyaXNiQURYZHBSUGJqbWJDTk9yd1JieEdaeDJYbVlOR01pVjVrakY0SUt5eENCdktpZXI5VTR1Vm9oZUNkbWs4M3JwNUcwUGloQW0yZkF0Y3pJNGI5QldxWCtuclpUckpYNWtTd1FkZGk5M05RclhHK0NsM2VCR05rTTc3VkJzTXBFb2xoWGV4MU1Wdk1rWk45Zkc1OUdHYmNpSDExRkVYYVkxTXhyQXJvdmFTakUvbFVVcUJnMmNaQk5taVdidnpDSENQSjRSVkdGSzJkVGJPYk0xbStnSnlFWDUzZmE3dTMrVFpwbTc0bU5Feldia1ZMNHZqTndmTDl1elJDdTFjZ2JyTng1WXY1ZERydU5ySU9nd0lrK1VaV3dKZmRidS9XSHVsNlBNbVJmbFZDSXpkN0IzN1BnbS9VcC9OdUNpUVc3Ulh5YWZldk4zQUw2eWNjaUNjNFpQbFRSekV1K2FVUkdsVUJPSmJVRXNoZVg3UFB5cnJoZFV0NUpBRzEyRUVFWnBZL04zVmhibDV1TEFmVDBDYkMyWG1wbnJ5Rmt4Wm1CVHM1cHJ2RWV1ZjBibjczaTNPODJXVGlRdEpXRVBMc0JYblFtZG5LaEIwNk5iYmhMdGxUWllKTXhETUpwRmVhalNOUkRCMnY2MUJNVUhxWGdnVXdSSjE5bTZwNXpsNTF2MTFxMzRUNzRsVFhkSlVSdVY2K2JnMkQ2cXBmR25MeTdLR0x1TFpuZ29iTTRwSW91ejQrbjAvVXpGS3hEZ0xNNGgrZlV3S1pvelE5VUdySGpjaWY1MVJ1b256N29JVlo1NnhXdFpTOHo3dTV6YXk2SjJMRDRnQ1loMlJYb0JSTERLc1VsWjgwUjhrbW94bEppTDhhWkN5MndDQW9ubnVjRnhDTFQxSEtvTWhiUEt0MzREOTdFWFBQaDBqb085M2lKVkYxVXJ1ZXc2MVFveTNaVVZOWDl1SUpEdDlBUVdLTExvK21Tem1UaWJ5TEhxMEQ2aGh6cHZnVWdJNmVreVZFTDNGRCtGaTVSM0E4TVJIUFhzcE4xVnlLa2ZSbEMrT0dpTmdQQzROUkVacEZFVGdWbWRYclEyVHhDaHVTM2FZK05kYzdDaVl2NStDbXpmaXFlWnJXSVFKVy9DNFJ2amJHVW9KRmYxSzZaZFIyeEwvYkc0a1ZxMStJNGpRV1grMjZZVWlqcHArbHBON281YzZab2RYSkNGNTZVa0ZHc3F6NDRzSWc4anJkV3ZialJDeGkyQmswaXlNM2E3ZWNBVjkzekI2aDFFaTM4YzBzNis4bnJia29wQXJjY0dQOHZudFFlMWJGZUVoMm5KSUZPSFgvazMvVUhiNVB0S0dwbnpia21uUkVUTVgrOVgvUWR1TFpXdy9mZWtsVy9rSC9KbnpUb0plOUtndTlIY3QxVUdiSDVCUENMbzRPT3RRblpvblcweG55Q2NkdEt5UFEvc2JMaVNUWUpkU3g0c0pxV0xNbmZuNmZJcVBCM1dBZ2swMEorZkNPa29tUEhxdFM2N3BmMG1GbUtvSXRZWlVsSnU2QmloU1o4cXZlOCsvWCtMWDFNaFFYRjk1QXNoZlVsZUN0bWRuNmw2UUZYekxnMnNnTG4xb3lWRnVaZWN2N2Z6c0lIem9SbEFHcDBnd1lET24xUzRxYWJXdkI1eFVhRStTdnc0S21qV3R4ZG51UWJJMzJkdzg3RDROOTV1OHFRUkpUU1FnMHdMeE9Ma3hTclBNTEVuMVVJaE5LakFhOVZMczNXTGFYR3J0Q0l0OGJLWTJBUVAvWmR5UlU2elQvRThxUDJsdHlCRTJDQ1pQZ1dnRVlEb0pKTzRuOTJ5NjF5bE5hU0ZYS29oSmhMamtmdllXbTU5MjUzOXNJcG1CTkxsRG8xYkV4RkJmbUhKSjBsRkVpQy9majh2NDJPb01DOU1vM3doSW9XdnlIZnE2VWFjcXE1NW16RmYvRUdDK05QL2dIamhkNnVyYzZSMGhFUzI3Vlh1eDdVWThDR0tQb2hwbFdJWnRUckZTYVBXc2xDV3k3OEUyMlB3OGZ2UmVTVVp4L3R4cUx0SHJGcWcxRFkvRXVzNklxMWhlWmRyZGNxRTAvYzk3MUJ6MUhXL1hOWEhzWHBVSWJJNGtIZE9mQ2M2VDV6SFp6dnpRSkIwZ2dNRkw2SUdQQWlsVTliai9BU2RQazZmTnZOdFpxUHV3RURoTUJ0Qm5oQ2V4bzZENlZBR0lPUHZKUFBWNTIzWThSOGE5dkNxWmJzd1NaS3pPVDEyOTFCc1VibVVXZWh0YmIxZmRSWDloaUpLWHZ3cjFRWDZHam5aTWd5TXZud09vMkRyMjRhbXI3RnFFQWJWZUpBalJOT2NlTTJFUTFNbmE5ZklucVBKNW1oNVg4Q3pUMWFET3YwOEFuMGJsejBmRjVHcTRtUzJjd3E1Z2x3SU9sWTVuem5FOFg0ai9VZFozRkpzVklYdGUxSkgwQTdpaWJ1UGZhelN0TTVPL1ZvM0tYSXBYQmVHT1JWME05WERYRnZzWVpVSEd2RkNVdWJXelR3MjQ4RUhFMGNwUU0yek5nNnJqYXZyZXEzTkhDQVdzb1o3d3ZWeTdsNWd2dEtSbUlqMU1udmZXRW0weUZuR2N1T3ExOTIzNTBhNVdlZnBmS0NjWDNTbitBZ0hVK3FucHN0TnRkZGJkVmViYWdKVTM5MGxxOWtvNGFJOXJxZGFXWFlHOHR2NU8vWlFIU3FEUllIQzZ6ZkgxMGw1eisrb3BzbzdhT1NhSWN6bFExM2lBelh2TGRFdTBWN2t3TlVaMWM4WThhcTdTZUlFZTVwOTAyRmxOa1c4RG53SHl1ZUhjaGJLOHZWRkpmbXI5bXo3UDhuVVNjY2wxVUxhb1dNUlNJMWxzMzJrdmxLMGg0NmgzSjI1WWQ5QXpmY0picDlxWUYvU0V0M0g1ajY5bU1kY3NOeFpjQXpUL0E4OW92M3RnbFRYNTR5L0V3ak1mdW9Eb3hQd0xKRG01STdxNkY5S3A0Njl5TnkxelN4ejBONEhiUlJCajl4RkZ1b2d2QnNwdjdEWFVOSXNHeFRJTkVRZm1jdGI0MlhJbVdBT0RnQVJObzdkZmNUcUZLcTZhVGZpdm12dW5MbXpQOWY4eUxzSnZYRDNKYmNQY0RHTnJpTUFjanplRFROcjY1dDhZQjV0c25GREZMYTBVd21kMk92VWRrTE1YOVRzQVVZVWZvb1N2NDdzdzVKODhqN0NwYWhSampPMy9VaE9YalRTMzlXNVlaQWVsMktUYlFkMWg3SU5PdzlQMjNHVzdHREFlNGFnSVVGSFA0OE1acjd1YnEwZWZGbW10d1lNeWs3RDByMW9lRy9DR09PRGdiOVVyK0pNSHhrd3pQYnRDWDJabkVOUXVJMFJONVN5VEladW9ZNFhTOVJkL3RQZTN2TkFaR1NITS9ZWXdxczl4a2tFTngwTytlQzJZVlcxY3dPSjNja0U4OTBuYlFlSExLbFcxNUwwUDBXMlZsaXlZcmZOcjBucklZZGRvUnlHYUN0ajRPWWQyTVQ3ZWJBcHFaT0FRSWFTSEpNNG1waGhmak5qdG5qZzZZUnl4OXFNMkZUM3hPaVlJTXFYUEZXZHpoU2dGRjhJdG9jcVZWMDlDbUlvTzhrNlUvb0pCNysrd1NYL1lrc3hmUFhIeWpTZ0FHWk9qMWFLRXE5ZlN2WEJxdHAyd3U4L0Z4RWY1QXhhcEFEMDZwUEd1TFZVWUxkZ0V6SFI4d3FSR1lFd2lVTzlNeVliZ3N3c3R1TFlod1lGcFNWS09kekFpaFo5THVIdEQ1OThFR2hJTlU5eGM5eGhMK1FnVExBc3RtUEl2dm0yeHlSdy9XVFVQWGtQM1pIdTZHeVBtajV4Rkg5L1FHcGtnbEtYUlZVQmdWbUxPSng4dVpPMkFzdHhRWW9jWkgySmhPUmx4YXdqNjZCQVhVRXM3Sy9nUHhJTklSQUZ5SzNXTHV5cTlvQlRGOXdFYm5tQ290ODJXaklnN0NQTndZSzNLclpNcktBejV5RnN6ZzR3Q1ZMSlZuSUw4K09ZQTB4UkRIOGNIUWpRVWlRMmkxbXIvYmUzMmsvM1hlajlzZGYzaXVHdlpIeUxGU0p2UFNxei93bHRueHVtVEpZS1pzcldYdHgvUm11MzlqalY5bEZhSnR0ZkZuNTcvTm8yaC91bnNKbU1IYnJuWjhjc3hrcDVIUTR4UjFzMEhIK3QzSXo4MmEzaVFXVFVER3EvK2wyVzNUVVlMRTh6TmRMOFkrNW9YYUlIL1kyVVVjWDY3Y1hlTjRXdkVOWmp6NCs4cTd2amhvd09JM3JTakZoR1o2S3p3bVU3KzVuRlYra0dXQVo1ejJVV3Z6cTBUSzBwazFoUHdBTjRqYncvLzFDQXBSdklhSWpoU0doaW9ZNlRVbXNUb2VrOWNGOVhqSmRIdkxQY3l5Q1YzbGJSNUppei90czQ2YXkyRjgyMFZqVFh2bGxFbHdyR3pLY05TeXZRbFdEWGR3clVJTlhtSG9yQU0zZkUxOW5nTFptZ2VVYUNKTHNTSVRmMlZjZkFPdVd3WDdtVFBkUDhaYi8wNEtxUm5pdWZDcHduRFVrN3NQMFJYNmN1ZC9zYW5GTWFnbnpLSW5TUlZleTBZemxWU090QS9BanJvZm1TSDZSWWJKUThiNE5EZVRrSUdjNjI0NytNbmJlei9xaEo5R0F2OWZHTkZlcmNQbm5yZjI4NVFncytVcVRoTFJnZmxjQUtGdXFXaEx6WmFSNFFxdlN3YTN4ZTBMUGtxajl4Sld1YjE5NXI3TnJyUjBlNzhGUiswbVJCTk1Qc3JhcVpjdEFVVkFKZllLZWhURFYxTUdHUVNlRHNPSzlKM3NiVXVLUklTL1dpbFgvNjRDQm1zOWpDWm9jQmxzQlNaYUlBaldtL1NVWjhkYVdMMmEvY0pGeVVPRnFFM0VwYzJSV2J0ak55UHdPR3BXdHp1MzJrVW9vVXFzSnVkN0lWNEU4cnN0VUJYTTd0R0V0Qng5OXg2MGcxZHVoeXZ4ZUtKU2w4czVFMzRIVE1tQURUMDgzNmFFZGc1RHY5clZ5Q3o4aTJSRU9taXo2d3RJVkZOMEhzakFvTjM3U3JZMGJWMU1zOENSVUlMaHZadnZSYUR6b1ZDYVNJMHU4RVB1VGU0YjdPUG93Z1JHT0RsMjJVQkJtSFNUVVk4ZTREeUwrQmM3Ym5nbysyVDhIdE52enlBVFNMNWlKWmdGUEtwbVV5WnY1NHZWTDkwKy9SUUdBVFVtTktuckl2Y0pNWU9OOWZsODNuYVc1c2Y2aFJrYmJUQzlSVUVFNlhBRHdqZ0E0NndXZlVRK1FXWmwwSjRQVlRXQWxuL1lmQXovU1YzcTNKOSt5Q1lEbGVydW9ONXVvYy93VDJmNFlPTkdUYjZ6VEdxM1YrM0pxem1DT2p3ZWJLbG4rZkV4VkxON3NxdHFmTW5zS1ZYV2JiMkFpNW0zRC9mQ1RnWDdvS1l6VFp2aittMjhYbkRxUGJYdVA0TXlXZG1QZXpjZXNkcmg3ckN6QTdCV2RPYml1eURFS2pqekJiUTBxbnV3amxpeitiK2o3YVBNS2xrWHlJem5WM3RHekFmWXdJYnpHR3QwOThvaDRlcTNydURqZGdIdGp4ZkZDakhyampSYkhham96L1lPWTRyYW9qUEZROTEwR0lsQlY3aHE0N1VEZ3B5YWpCeFFVbUQ4TmN0aUxWMXJUU0xBRXNRRExUZVJLY21QQk1WTUZGMFNQQkJoWjVvWG94dEQzbE1odUFRWG1BKzU3T2NjaWN6Vlc5ZTl6d1NJQUhTK0ZKbXZmWE1KR0YxZE1Cc0lVTWFQanZnYVZxVWMzcDMycVZDTVFZRkVpUkx6bFZTT0dNQ212L0hKSXhBSGUzbUwvWG5vWjFJa1dMZVJaZmd5QnlqbkRiYmVSSzVLTDdiWUhTVkpaOVVGcSt5Q2lOS2VSVWFZamdiQzNoVlV2ZkpBaHkvUU5sL0pxTEtWdkdNazlaY2Z5R2lkTmVvL1ZUeEs5dlVwb2R6ZlFJOVoyZUFyZTRubXJremd4S1NuVDVJSjFENjlvSHVVUzVocDdwSzlJQVd1TnJBT3RPSDBtQXV3Q3JZOG1YQXRWWFVlYU5LM09YcjZQUnZtV2c0VlFxRlN5K2ExR1pmRllnZHNKRUxHOE4wa3ZxbXp2d1owMlBsZjVmSDlRVHk2YnIwb1kvSURzRUErR0JmOXBFVldDSXVCQ2pzdXAzTERTRHFJKzUrMElLU1VGcjdBOTZBMmYwRmJjVTlmcWxqZHF2c2Q4c0c1NUtjS2xvSElGWmVtMldiNnBDTFh5Ym5WU0Iwc2pDWHpkUzhJS3ZFJyk7XG5jb25zdCBGRU5DRUQgPSBuZXcgTWFwKFtbODIxNyxcImFwb3N0cm9waGVcIl0sWzgyNjAsXCJmcmFjdGlvbiBzbGFzaFwiXSxbMTI1MzksXCJtaWRkbGUgZG90XCJdXSk7XG5jb25zdCBOU01fTUFYID0gNDtcblxuZnVuY3Rpb24gaGV4X2NwKGNwKSB7XHJcblx0cmV0dXJuIGNwLnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpLnBhZFN0YXJ0KDIsICcwJyk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIHF1b3RlX2NwKGNwKSB7XHJcblx0cmV0dXJuIGB7JHtoZXhfY3AoY3ApfX1gOyAvLyByYWZmeSBjb252ZW50aW9uOiBsaWtlIFwiXFx1e1h9XCIgdy9vIHRoZSBcIlxcdVwiXHJcbn1cclxuXHJcbi8qXHJcbmV4cG9ydCBmdW5jdGlvbiBleHBsb2RlX2NwKHMpIHtcclxuXHRyZXR1cm4gWy4uLnNdLm1hcChjID0+IGMuY29kZVBvaW50QXQoMCkpO1xyXG59XHJcbiovXHJcbmZ1bmN0aW9uIGV4cGxvZGVfY3AocykgeyAvLyB0aGlzIGlzIGFib3V0IDJ4IGZhc3RlclxyXG5cdGxldCBjcHMgPSBbXTtcclxuXHRmb3IgKGxldCBwb3MgPSAwLCBsZW4gPSBzLmxlbmd0aDsgcG9zIDwgbGVuOyApIHtcclxuXHRcdGxldCBjcCA9IHMuY29kZVBvaW50QXQocG9zKTtcclxuXHRcdHBvcyArPSBjcCA8IDB4MTAwMDAgPyAxIDogMjtcclxuXHRcdGNwcy5wdXNoKGNwKTtcclxuXHR9XHJcblx0cmV0dXJuIGNwcztcclxufVxyXG5cclxuZnVuY3Rpb24gc3RyX2Zyb21fY3BzKGNwcykge1xyXG5cdGNvbnN0IGNodW5rID0gNDA5NjtcclxuXHRsZXQgbGVuID0gY3BzLmxlbmd0aDtcclxuXHRpZiAobGVuIDwgY2h1bmspIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMpO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgKSB7XHJcblx0XHRidWYucHVzaChTdHJpbmcuZnJvbUNvZGVQb2ludCguLi5jcHMuc2xpY2UoaSwgaSArPSBjaHVuaykpKTtcclxuXHR9XHJcblx0cmV0dXJuIGJ1Zi5qb2luKCcnKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcGFyZV9hcnJheXMoYSwgYikge1xyXG5cdGxldCBuID0gYS5sZW5ndGg7XHJcblx0bGV0IGMgPSBuIC0gYi5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGMgPT0gMCAmJiBpIDwgbjsgaSsrKSBjID0gYVtpXSAtIGJbaV07XHJcblx0cmV0dXJuIGM7XHJcbn1cblxuLy8gY3JlYXRlZCAyMDIzLTAyLTIxVDA5OjE4OjEzLjU0OVpcbnZhciByID0gcmVhZF9jb21wcmVzc2VkX3BheWxvYWQoJ0FFVURUQUhCQ0ZRQVRRRFJBREFBY2dBZ0FEUUFGQUFzQUJRQUh3QU9BQ1FBRFFBUkFBb0FGd0FIQUJJQUNBQVBBQVVBQ3dBRkFBd0FCQUFRQUFNQUJ3QUVBQW9BQlFBSUFBSUFDZ0FCQUFRQUZBQUxBQUlBQ3dBQkFBSUFBUUFIQUFNQUF3QUVBQXNBREFBTUFBd0FDZ0FOQUEwQUF3QUtBQWtBQkFBZEFBWUFad0RTQWRzREpnQzBDa01COHhoWkFxZm9DMTkwVUdjVGhnQnVyd2Y3UFQwOVBiMDlBamdKdW04T2pEbGx4SFlVS1hBUHh6cTZ0QUJBeGdLOHlzVXZXQWdNUFQwOVBUMDlQU3M2TFQySGNnV1hXd0ZMb1NNRUVFbDVSRlZNS3ZPMFhROEV4RGRKTW5JZ3NqMjZQVFF5eThGZkVROEFZOElQQUdjRWJ3UndCSEVFY2dSekJIUUVkUVIyQkhjRWVBUjZCSHNFZkFSK0JJQUVnZm5kQlFvQllnVUxBV0lGREFGaUJOY0UyQVRaQlJBRkVRVXZCZEFMRkFzVkRQY05CdzEzRFljT01BNHhEak1CNEJsbEhJMEIyZ3JiQU1EcEhMa1E3UUhWQVBSTlFRRm5HUlVFZzB5RUIydWFKRjhBSnBJQnBvYjVBRVJTTUFLTm9BWHFhUUxVQk1DekVpQUNud1JaRWtrVnNTN3RBTkFzQkcwUnVBUUxFUEFCdjlISUNUVUJYaWdQWndSQkFwTURPd0FhbWh0YUFCcUVBWThLdkt4M0xRNEFyQUI4VWh3RUJBVlNhZ0Q4QUVGWkFEa0JJYWRWajJVTVVneDVJbDRBTlFDOUF4SUIxQmxiRVBNQXMzMENHeGxYQWh3WktRSUVDQmM2RWJzQ294bmd6djdVelJRQThNMEJhd0w2WndrTjd3QUJBRDMzT1FSY3NnTEpDak1DanFVQ2h0dy9rbStOQXNYUEFvUDJCVDg0UHdVUkFLMFJBdnB0YjZjQXBRUy9PTU1leTVISlM4NFVkeHB4VFBrQ29nVkZJVGFUT3dFUkFLNXBBdmtOQk9WeUE3cTNCS2xPSlNBTEFnVUlCUmNFZEFTcEJYcXpBQlhGU1daT2F3TENPcXcvL0FvbENaZHZ2M2RTQmtFUUd5ZWxFUGNNTXdHMUFUc043VXZZQlBFR093VEpIMzBaR1EvTmxad0lwUzNkRE8wbTR5NmhnRm9qOVNxREJlMUw5RHpkQzAxUmFBOVpDMlVKNHpwamdVNERJUUVOSW9zSzNRMDVDRzBROHdySmF3M2xFVVVIT1FQVlNab0FwUWNCQ3hFZE5SVzFKaEJpckFzSk9YY0creHIyQzQ4bXJ4TXBldndGMHhvaEJrMEJLUnIvQU04dTU0V3dXakZjSEU5ZkJnTUxKU1BIRktoUUlBMGxRTGQ0U0JvYkJ4VWxxUUtSUTNCS2gxRTJIcE1oOWp3OURXWXVFMUY4Qi9VOEJSbFBDNEU4bmthclJRNFIwajZOUFVnaVNVd3NCRFYvTEM4bml3blBENFVNdVh4eUFWa0pJUW14REhFVE1SRVhOOFVJT1FjWkxaY2tKeFVJSVVhVllKb0U5NThEOHhQUkF3c0ZQd2xCQnhNRHRSd3RFeTRWS1FVTmdTVFhBdk0yMVM2ekFvOVdnQUVYQmNzUEpSL2ZFRkJINEE3cENKc0NaUU9ESmVzQUxSVWhBQmNpbXdoRFl3QmZqOWhUQlM3TENNZHFiQ04wQTJjVTUyRVJjd2VSRGxjSHB4d3pGYjhjNFhESVhndUdDQ2lqcndsYkFYVUptUUZmQk9NSUNUVmJqS0FnUVdkVGkxZ1lteUJoUVQ5ZC9BSXhER1VWbjBTOWgzZ0NpdzlyRWhzQk5RRnpCemtOQVFKM0VlMFJheENWQ091R0JEVzFNL2c2SlFSUElZTWdFUW9uQTA5c3pnc25KdmtNK0drQm94SmlBd3cwUFhmdVo2dGd0aVFYL1FjWk1zVkJZQ0h4QzVKUHpReWNHc0VZUWxRdUdlUUh2d1B6R3ZNbjZrRlhCZjhEb3dNVE9rMHo3Z1M5QzJrSWl3ay9BRWtPb3hjSDF4aHFDbkdNMEFFeGl3RzNtUU5Ya1lNQ2I0OEdOd2NMQUdjTGh3VjU1UUFkQXFjSW93QUZBTThEVndBNUFxMEhuUUFaQUlWQkFUMERKeThCSWVVQ2p3T1RDREhMQVpVdkFmTXBCQnZEREJVQTl6ZHVTZ0xEc1FLQWFtYWlCZDFZQW80Q1NUVUJUU1VFQlU1SFVRT3ZjZUVBMndCTEJoUGZSd0VWcTByTEd1TkRBZDl2S3dESEFQc0FCVFVIQlVFQnpRSHpiUUMzQVY4TE1RbWlzN1VCVGVrcEFJTUFGV3NCMXdLSkFOMEFOUUIvOFFGVEFFMEZXZmtGMHdKUFNRRVJNUmdyVjJFQnV3TWZBVE1CRFFCNUJzdU5wY2tISHdSdEI5TUNFQnNWNFFMdkxnZTFBUU1pM3hQTlFzVUN2ZDVWb1dBQ1pJRUNZa0piVGE5Yk55QUNvZmNDYUpnQ1pna0NuNFE0R3dzQ1pqc0NaaVlFYmdSL0EzOFRBMzZTT1FZNWR4YzVnam9qSXdKc0hRSXlOamdLQW0zSEFtMnU3NG96WjBVckFXY0EzZ0RoQUVvRkI1Z01qUUQrQzhJQURiVUNkeThDZHFJL0FubExRd0o0dWgxYzIwV3VSdGNDZkQ4Q2VzZ0NmUWtDZlBBRldRVWdTQUJJZldNa0FvRnRBb0FBQW9BRkFuK3VTVmhLV3hVWFNzd0MwUUVDME14TEp3T0lUd09INWtURmtUSUM4cUZkQXdNRHJrdk9UQzBsQTg5TlRFMnZBb3MvQW9yWXdSc0hIVU5uQmJjQ2pqY0NqbHhBbDRFQ2p0a0NqbHg0VWJSVE5RcFMxRlNGQXBQN0FwTU1BT2tBSEZVZVZhOVYwQVlzR3ltVmhqTGhlR1pGT3prQ2w1OEM3N0pZSWFnQVdTVUNsbzhDbG55Y0FLbFpyRm9KZ1UwQU93S1d0UUtXVGx4RVhORUNtY3NDbVdSY3lsMEhHUUtjbXpuQ09wMENuQllDbjVzQ25yaUtBQjBQTVNvUEFwM3hBcDZTQUxVOVlUUmg3d0tlMHdLZ2JnR3BBcDZmSHdLZVRxVmp5R1FuSlNzQ0o2OENKbjRDb1BzQ29Fd0NvdDBDb2NRQ3BpOENwYzRDcC84QWZRS244bWg4YUxFQUEwbHFIR3JSQXF6akFxeXVBcTFuQXEwQ0FsY2RBbFhjQXJIaDF3TWZUbXlYQXJLOURRS3k2QmRzNEcxamJVaGZBeVhOQXJaY096OXVrQU1wUlFLNFhnSzVSeFVDdVNwM2NEWnc0UUs5R1FLNzJuQ1dBeklSQXI2SWNnSURNM0VDdmhwekluTlBBc1BMQXNNRWM0SjBTelZGZE9BRFBLY0RQSm9EUGI4Q3hYd0N4a2NDeGhDSkFzaHBVUUxJUkFMSlR3TEpMZ0prblFMZDBuaDVZWGl1ZVNWTDBBTVlvMmNDQW1IMEdmT1ZKSHNMWHBKZXV4RUN6MnNDejJ3dlMxUFM4eE9mQU1hdEFzOXpBU25xQTA0U2Zrc0ZBdHduQXR1S0F0SlBBMUpjQTFOZkFRRURWWXlBaVQ4QXl4YnRZRVdDSElMVGdzNkRqUUxheHdMWjNvUVFoRW1uUEFPR3BRQXZBMlFPaG5GWitRQlZBdDlsQXQ2NGMzY0M0aS90RkFIek1DY0I5SnNCOHRLSEF1dnpBdWx3ZVFMcStRTHE1QUQ1UndHNUF1NkpBdXVjbHFxWEF3THVQd09GNEpoNWNPQnhvUUx6QXdCcEE0NFdtWk1DOXhNRGtXNERrb2NDOTVnQytka0MrR2FhSEpxcnV6ZWJIZ09kZ3dMKytnRWJBRG1mSEorekF3V05BNlpxQTZiWkFOSEZBd1pxb1lpaUJRa0RERWtDd0FBL0F3RGhRUmRUQVJIekEyc0hsMmNGQUpNdEs3ZXZ2ZHNCaVprVWZ4RUVPUUg3S1FVaERwMEpud0NTL1NsWHhRTDNBWjBBdHdXNUFHOExiVUV1RkNhTkxnRkRBWUQ4QWJVbUFIVUREZ1J0QUN3Q0ZneWhBQUFLQWowQ2FnUGRBMzRFa1FFZ1JRVWhmQW9BQlFCRUFCTUFOaElDZHdFQUJkVURhKzhLeFFJQTl3cWZKNyt4dCtVQmtTRkJRZ0hwRkg4Uk5NQ0pBQVFBR3dCYUFrVUNoSXNBQmpwVE9wU05iUUM0T284NjBBQ05PTUU2M0FDbEFPZ0F5d0U2Z1RvN09mdzUrVHQyaVRwYk81NkpPbTg1R0FGV0FUTUJiQVV2TlYwMW5qV3ROV1kxZFRXMk5jVTFnaldSTmRJMTRUV2VOYTAxN2pYOU5iSTF3VFlDTmhFMXhqWFZOaFkySnpYZU5lMDJMalk5Tmk0MUxTRTJPalk5Tmp3MnlUY0lCSkE4VnpZNE50MDNJRGNQTnNvZ040azNNQW9Fc0R4bk5pUTNHVGRzT28wM0lVTFVRd2RDNEVNTEhBOFBDWnNvYlNoUlZRWUE2WDhBNmJBQkZDblhBdWtCb3dDOUJiY0Fid056Qkw4TURBTU1BUWdEQUFrS0N3c0xDUW9HQkFWVkJJL0R2d0R6OWIyOWthVUNiMFF0c1JUTkx0NGVHQmNTSEFNWkZoWVpFaFlFQVJBRUJVRWNRUnhCSEVFY1FSeEJIRUVhUVJ4QkhFRkNTVHhCUEVsSVNVaEJOa00yUVRZYk5rbElTVm1CVklnQkZMV1pBdTBCaFFDakJjRUFieWtCdndHSkFhUWNFWjBlUENrbE1BQWhNdkFJTUFMNTRnQzdCbThFZXNjanpRTXBBUlFwS2dEVUFCYXZBajYyNnhRQUpQMEEzZXR6dWY0Tk5SQTdlZnkyWjlOUXJDbkMwT1N5QU56NUJCSWJKNUlGRFI2bWlJYXZZUzZ0cHJqam11S2VieG01Qzc0UTIyNVgxcGthWVlQYjZmMURLNGszeE1FQmI5UzJXTWpFaWJUTldoc1JKSUErdndOVkVpWFRFNWlYcy93ZXpWNjZvRkxmcDlOWkdZVytHazE5SjIrYkNUNlllMnc2TERZZGd6S01VYWJrNTk1ZUxCQ1hBTno5SFVwV2JBVHE5dnFYVng5WERnK1BjOVhwNCtic1MwMDVTVk0vQkpCTTQ2ODdXVXVmK1VqOWRFaThhRE5hUHh0cGJEeGNHMVRIVEltVU1acTRVQ2FhTllwc1ZxcmFOeUtMSlhEWXNGWi81amw3YkxSdE84OHQ3UDN4WmFBeGhiNU9kUE1YcXNTa3AxV0NpZUc4alhtMVU5OStibHZMbFh6UENTK005M1ZuSkNpSyswOUxmYVNhQkFWQm9teURnSnVhOGRmVXpSN2dhMzRJdlIyTnZqK0E5aGVKNmxzbDFLRzROa0kxMDMyQ25mZjFtMXdvZjJCOW9ISks0Ymk2SmtFZFNxZU5laXVvNlFvWlppbmNvYzczL1RIOVNYRjhzQ0U3WHl1WXlXOFdTZ2JHRkNqUFYwaWhMS2hkUHMwOFR4ODJmWUFrTExjNEkyd2RsNGFwWTdHVTVsSFJGelJXSmVwN1d3M3diZUEzcW1kNTkvODZQNHh1TmFxRHB5Z1h0Nk04NWdsU0JIT0NHZ0pEbnQrcE45Yks3SEFwTWd1WDYrMDZSWk5qelZtY1pKK3djVXJKOS8vYnBSTnhOdUtwTmw5dUZkcytTOXRkeDdMYU01WmtJclBqNm5JVTltbmJGdFZiczlzL3VMZ2w4TVZjekF3ZXQraU9FenpCbFlXN1JDTWdFNmd5TkxlcTYrMXRJeDRkcGdabmQwRGtzSlM1ZitKTkRwd3djUE5YYWFWc3BxMWZiUWFqT3JKZ0swb2ZLdEoxTmU5MEw2Vk80TU9sNVM4ODZwN3U2eG83T0xqRzhUR0wrSFUxSlhHSmdwcGc0bk5iTko1bmx6U3B1UFl5MjFKVUVjVUE5NFBvRmlaZmpadWUrUW55UTgwZWtPdVpWa3h4NGcrY3ZoSmZIZ05sNGh5MS9hNitSS2NLbGFyL0oyOXkvL0V6dGxiVlBIVlVlUTF6WDg2ZVFWQWpSL00zZEE5dzRXOExmYVhwNEVnTTg1d09XYXNsaTgzN1B6Vk1PbnNMelIrazNvNzUvbFJQQUpTRTF4QUtRekVpNXYxMGtlK1ZCdlJ0MWN3UVJNZCtVNW1MQ1RHVmQ2WGladGdCRzVjRGkwdzIyR0tjVk52SGl1NUxRYlpFRFZ0ejBvbm43azUraGV1S1hWc1p0U3ppbGtMUkFVbWpNWEVNQjNKOVlDNTBYQnhQaXo1M1NDK0VoblBsOVdzS0N2OTJTTS9PRkZJTUpaWWZsMFdXOHRJTzNVeFljd2RNQWo3RlNtZ3JzWjJhQVpPMDNCT2hQMWJOTlpJdHlYWVFGVHBDM1NHMVZ1UERxSDlHa2lDRG1FK0p3eHlJVlNPNXNpREVyQU9wRVhGZ2p5NlBRdE9WRGorczZlMXI4aGVXVnZtWm5UY2l1ZjRFaU5aekNBZDdTT01oWEVSSU9sc0hJTUczOTlpOWFMVHkzbTJoUkxaakpWRE5MUzUzaUdJSzExZFBxUXQwekJEeWc2cWM3WXFrRG0yTTVWZTZkQ1dDYUNiVFhYMnJUb2FJZ3o2K3poNGxZVWkvKzZucWNGTUFrUUpLSFlMSzB3WWs1TjlzelY2eGloRGJEREZyNDVsTjFLNGFDWEJxL0ZpdFBTdWQ5Z0x0NVpWbitacUdYN2N3bTJ6NUVHTWdmRnBJRnloR0d1RFBtc282VEl0VE13bnkrN3VQbkxDZjRXNmdvRlFGVjBvUVNzYzlWZk1tVkxjTHI2WmV0RFpiYVNGVExxblNPL2JJUGpBMy96QVVvcWdHRkFFUVM0SWh1TXpFcDJJM2pKemJ6a2svSUVteWF4K3JoWlR3ZDZmK0NHdHdQaXh1OEl2ekFDcXVQV1BSRXU5WnZHa1V6cFJ3dlJSdWFOTjZjcjBXMXdXaXRzOUlDZFlKN2x0YmdNaVNMM3NUUGV1ZmdOY1ZxTVZXRmtDUERINGpHMmpBMFhjVmdRajYyQ2IyOXY5Zi96LysyS2JZdkl2L3p6anBRQVBrbGlhVkR6TnJXNTdUWi9aT3laRDBubGZNbUFJQklBR0FJMEQzay9tZE40eHI5djg1WmJaYmJxZkgyakdkNWhVcU5aV3dsNVNQZm9HbWZFbG1helVJZU5MMWovbWtGN1ZOQXpUcTRqTnQ4Sm9RMTFOUU9jbWhwclhveFN4ZlJHSjlMREVPQVErZG14QVFIOTBpdGk5ZTJ1L01vZXVhR2NEVEhvQyt4c21FZVdteEVLZWZRdUl6SGJwdzVUYzVjRW9jYm9BRDA5b2lwV1FodFRPMXdpdmYvTytEUmUycnBsL0U5d2xyekJvcmpKc09lRzFCL1hQVzRFYUpFRmRObEVDRVpnYTVab0dSSFhnWW91R1J1VmttOHRERVNpRXlGTm8rM3M1TTVwdVNkVHlVTDJsbG5JTlZIRXQ5MVhVTlc0ZXdkTWdKNGJvSmZFeXQvaVk1V1hxYkErQTJGa3Q1WjBsdXRpV2hlOW5aSXlJVWp5WERDM1VzYUcxdCtlTng2ejRXL09Zb1RCN0E2eCtkTlNUT2k5QUluY3RiRVNxbTVndk9Md3c3T1dYUHJtSHdWWmFzcmw0ZUQxMTNwbStKdFQ3SlZPdm5DWHFkenpkVFJIZ0owUGlHVEZZVzVHdnQ5UjlMRDZMemZzMHYvVFpaSFNteVZOcTd2aUlIRTZEQks3UXAwN0l6NTVFTThTWXRRdlpmL29iQm5pVFdpNUMyL292SGZ3NFZuZGtFNVhZZGpPaENNUmpEZU9FZlhlTi9Dd2ZHZHVpVUlmc29GZVV4WGVRWGJhN2M3OTcyWE52OHcrZFRqalVNMFFlTkFSZVcrSjAxNGRLQUQvTWNRWVhUN2MwR1FQSWtuM0xsNlI3Z0dqdWlRb1pEMFRFZUVxUXBLb1oxNWcvME9QUUkxN1FpU3Y5QVVST2EvVi9UUU4zZHZMQXJlYzNScnNZbHZCbTFiOExXemx0ZHVnc0M1MGxOS1lMRXAyYStaWllxUGVqVUxSbE9KaDV6ai9MVk15VER2d0toTXh4d3VEa3hKMVFwb05JME9UV0xvbTRaNzFTTnpJOVRWMWlYSnJJdTlXY25kK01DYUF3OG8xalNYZDk0WVUvMWdua3JDOUJVRU90UXZFSVE3ZzBpNmgrS0wySktrOFlkbDdIcnV2Z1dNU0FtTmUrTHNoR2hWNHFuV0hoTzkvUklQUXpZMXRIUmoyVnFPeU5zRHBLMGN3dys1NkFkREM0Z3NXd1kwWHhvdWNJV0lxcy9HY3duV3FsYVQwS1ByOG1iSzVVOTQvMzAxaTFXTHQ0WUlOVFZ2Q0ZCckZaYkliWThleWNPZGVKMnRlRDVJZlBMQ1JnN2pqY0ZUd2xNRk5sOXpkaC9vM0UvaEhQd2o3QldnME1VMDlwUHJCTGJyQ2dtNTRBNkgrSTZ2Mjcrakw1Z2tqV2cvaVlka3M5amJmVlA1eS9uMGRsZ1dFTWxLYXNsN0p2RlpkNTZMZnliVzFlZWFWTzBneFRmWFp3RDhHNFNJMTE2eXg3VUtWUmd1aTZZYTFZcGl4cVhlTkxjOEl4dEF3Q1U1SWh3UWduK05xSG5SYUR2NjFDeEtoT3E0cE9YN002cGtBK1BtcGQ0ajF2bjZBQ1VBTG9MTGM0dnBYY2k4VmlkTHh6bTdxRkJlN3MrcXV1SnM2RVRZbW5wZ1MzTHdTWnhQSWx0Z0JEWHo4TTFrL1cyeVNOdjJmOS9OUGh4TEdLMkQyMWRrSGVTR21lblJUM1lxY2RsMG0vaDNPWXI4VitsWE5ZR2Y4YUNDcGQ0YldqRTRRSVBqN3ZVS040TnJmczdNTDZZMk95UzgzMEpDbm9mZy9rN2xwRnB0NFNxWmM1SEdnMUhDT3JIdk9kQzhiUDZGR0RiRS9WVjBtWDRJYWt6YmRTL29wK0t0M0cyNC84UWJCVjd5ODZzR1NRL3ZaelU4RlhzN3U2akl2d2Noc0VQMkJwSWhXM0c4dVdOd2EzSG1qZkgvWmpoaENXdmx1QWNGK25NZjE0Q2xLZzVoR2d0UExKOTh1ZU5Ba2M1SHMyV1psazJRSHZmcmVDSzFDQ0dPNm5NWlZTYjk5Vk0vYWpyOFdIVHRlOUpTbWtYcS9pL1U5NDNIRWJkelc2UmUvUzg4ZEtnZzhwR09MbEFlTmlxcmNMa1VSMy9hQ2xGcE1YY09VUDNybUVUY1dTZk1YWkUzVFVPaThpK2ZxUm5UWUxmbFZ4L1ZiLzZHSjdlSVJaVUE2azNSWVIzaUZTSzljNGlEZE53SnVaTDJGS3ovSUs1VmltY05XRXFkWGpTb3hTZ21GMFVQbERvVWxOclBjTTdmdG1BOFk5Z0tpcUtFSHVXTitBWlJJd3RWU3h5ZTJLZjhyTTNsaEo1WGNCWFU5bjR2ME95MVJVMk0rNHFNOEFRUFZ3c2U4RXJOU29iNW9GUFd4dXFablZ6bzFxQi9JQnhrTTNFVlVLRlVVbE8zZTUxMjU5R2dOY0piQ21sdnJkanRvVFc3ckNobTF3eUNLenBDVHdvelVVRU9JY1dMbmVSTGdNWGgrU2pHU0ZrQWxsemJHUzVISzdMbGZDTVJOUkRTdmJRUGpjWGFlbk5ZeEN2dTJReXpuejZTdHV4Vmo2NlNnSTBUOEI2L3NmSEFKWVphWjc4dGhqT1NJRnVtTldMUWJlWml4RENDQyt2MFlCdGt4aUJCM2plZkhxWi9kRkhVK2NyYmo2T3ZTMXgvSkREN3ZsbTd6T1ZQd3BVQzAxbmh4WnVZLzYzRTdnJyk7XG5cbi8vIGh0dHBzOi8vdW5pY29kZS5vcmcvcmVwb3J0cy90cjE1L1xyXG5cclxuZnVuY3Rpb24gdW5wYWNrX2NjKHBhY2tlZCkge1xyXG5cdHJldHVybiAocGFja2VkID4+IDI0KSAmIDB4RkY7XHJcbn1cclxuZnVuY3Rpb24gdW5wYWNrX2NwKHBhY2tlZCkge1xyXG5cdHJldHVybiBwYWNrZWQgJiAweEZGRkZGRjtcclxufVxyXG5cclxuY29uc3QgU0hJRlRFRF9SQU5LID0gbmV3IE1hcChyZWFkX3NvcnRlZF9hcnJheXMocikuZmxhdE1hcCgodiwgaSkgPT4gdi5tYXAoeCA9PiBbeCwgKGkrMSkgPDwgMjRdKSkpOyAvLyBwcmUtc2hpZnRlZFxyXG5jb25zdCBFWENMVVNJT05TID0gbmV3IFNldChyZWFkX3NvcnRlZChyKSk7XHJcbmNvbnN0IERFQ09NUCA9IG5ldyBNYXAoKTtcclxuY29uc3QgUkVDT01QID0gbmV3IE1hcCgpO1xyXG5mb3IgKGxldCBbY3AsIGNwc10gb2YgcmVhZF9tYXBwZWQocikpIHtcclxuXHRpZiAoIUVYQ0xVU0lPTlMuaGFzKGNwKSAmJiBjcHMubGVuZ3RoID09IDIpIHtcclxuXHRcdGxldCBbYSwgYl0gPSBjcHM7XHJcblx0XHRsZXQgYnVja2V0ID0gUkVDT01QLmdldChhKTtcclxuXHRcdGlmICghYnVja2V0KSB7XHJcblx0XHRcdGJ1Y2tldCA9IG5ldyBNYXAoKTtcclxuXHRcdFx0UkVDT01QLnNldChhLCBidWNrZXQpO1xyXG5cdFx0fVxyXG5cdFx0YnVja2V0LnNldChiLCBjcCk7XHJcblx0fVxyXG5cdERFQ09NUC5zZXQoY3AsIGNwcy5yZXZlcnNlKCkpOyAvLyBzdG9yZWQgcmV2ZXJzZWRcclxufVxyXG5cclxuLy8gYWxnb3JpdGhtaWMgaGFuZ3VsXHJcbi8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3ZlcnNpb25zL1VuaWNvZGUxNS4wLjAvY2gwMy5wZGYgKHBhZ2UgMTQ0KVxyXG5jb25zdCBTMCA9IDB4QUMwMDtcclxuY29uc3QgTDAgPSAweDExMDA7XHJcbmNvbnN0IFYwID0gMHgxMTYxO1xyXG5jb25zdCBUMCA9IDB4MTFBNztcclxuY29uc3QgTF9DT1VOVCA9IDE5O1xyXG5jb25zdCBWX0NPVU5UID0gMjE7XHJcbmNvbnN0IFRfQ09VTlQgPSAyODtcclxuY29uc3QgTl9DT1VOVCA9IFZfQ09VTlQgKiBUX0NPVU5UO1xyXG5jb25zdCBTX0NPVU5UID0gTF9DT1VOVCAqIE5fQ09VTlQ7XHJcbmNvbnN0IFMxID0gUzAgKyBTX0NPVU5UO1xyXG5jb25zdCBMMSA9IEwwICsgTF9DT1VOVDtcclxuY29uc3QgVjEgPSBWMCArIFZfQ09VTlQ7XHJcbmNvbnN0IFQxID0gVDAgKyBUX0NPVU5UO1xyXG5cclxuZnVuY3Rpb24gaXNfaGFuZ3VsKGNwKSB7XHJcblx0cmV0dXJuIGNwID49IFMwICYmIGNwIDwgUzE7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNvbXBvc2VfcGFpcihhLCBiKSB7XHJcblx0aWYgKGEgPj0gTDAgJiYgYSA8IEwxICYmIGIgPj0gVjAgJiYgYiA8IFYxKSB7XHJcblx0XHRyZXR1cm4gUzAgKyAoYSAtIEwwKSAqIE5fQ09VTlQgKyAoYiAtIFYwKSAqIFRfQ09VTlQ7XHJcblx0fSBlbHNlIGlmIChpc19oYW5ndWwoYSkgJiYgYiA+IFQwICYmIGIgPCBUMSAmJiAoYSAtIFMwKSAlIFRfQ09VTlQgPT0gMCkge1xyXG5cdFx0cmV0dXJuIGEgKyAoYiAtIFQwKTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0bGV0IHJlY29tcCA9IFJFQ09NUC5nZXQoYSk7XHJcblx0XHRpZiAocmVjb21wKSB7XHJcblx0XHRcdHJlY29tcCA9IHJlY29tcC5nZXQoYik7XHJcblx0XHRcdGlmIChyZWNvbXApIHtcclxuXHRcdFx0XHRyZXR1cm4gcmVjb21wO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gLTE7XHJcblx0fVxyXG59XHJcblxyXG5mdW5jdGlvbiBkZWNvbXBvc2VkKGNwcykge1xyXG5cdGxldCByZXQgPSBbXTtcclxuXHRsZXQgYnVmID0gW107XHJcblx0bGV0IGNoZWNrX29yZGVyID0gZmFsc2U7XHJcblx0ZnVuY3Rpb24gYWRkKGNwKSB7XHJcblx0XHRsZXQgY2MgPSBTSElGVEVEX1JBTksuZ2V0KGNwKTtcclxuXHRcdGlmIChjYykge1xyXG5cdFx0XHRjaGVja19vcmRlciA9IHRydWU7XHJcblx0XHRcdGNwIHw9IGNjO1xyXG5cdFx0fVxyXG5cdFx0cmV0LnB1c2goY3ApO1xyXG5cdH1cclxuXHRmb3IgKGxldCBjcCBvZiBjcHMpIHtcclxuXHRcdHdoaWxlICh0cnVlKSB7XHJcblx0XHRcdGlmIChjcCA8IDB4ODApIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH0gZWxzZSBpZiAoaXNfaGFuZ3VsKGNwKSkge1xyXG5cdFx0XHRcdGxldCBzX2luZGV4ID0gY3AgLSBTMDtcclxuXHRcdFx0XHRsZXQgbF9pbmRleCA9IHNfaW5kZXggLyBOX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdl9pbmRleCA9IChzX2luZGV4ICUgTl9DT1VOVCkgLyBUX0NPVU5UIHwgMDtcclxuXHRcdFx0XHRsZXQgdF9pbmRleCA9IHNfaW5kZXggJSBUX0NPVU5UO1xyXG5cdFx0XHRcdGFkZChMMCArIGxfaW5kZXgpO1xyXG5cdFx0XHRcdGFkZChWMCArIHZfaW5kZXgpO1xyXG5cdFx0XHRcdGlmICh0X2luZGV4ID4gMCkgYWRkKFQwICsgdF9pbmRleCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IG1hcHBlZCA9IERFQ09NUC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChtYXBwZWQpIHtcclxuXHRcdFx0XHRcdGJ1Zi5wdXNoKC4uLm1hcHBlZCk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGFkZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdGlmICghYnVmLmxlbmd0aCkgYnJlYWs7XHJcblx0XHRcdGNwID0gYnVmLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAoY2hlY2tfb3JkZXIgJiYgcmV0Lmxlbmd0aCA+IDEpIHtcclxuXHRcdGxldCBwcmV2X2NjID0gdW5wYWNrX2NjKHJldFswXSk7XHJcblx0XHRmb3IgKGxldCBpID0gMTsgaSA8IHJldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRsZXQgY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdFx0aWYgKGNjID09IDAgfHwgcHJldl9jYyA8PSBjYykge1xyXG5cdFx0XHRcdHByZXZfY2MgPSBjYztcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsZXQgaiA9IGktMTtcclxuXHRcdFx0d2hpbGUgKHRydWUpIHtcclxuXHRcdFx0XHRsZXQgdG1wID0gcmV0W2orMV07XHJcblx0XHRcdFx0cmV0W2orMV0gPSByZXRbal07XHJcblx0XHRcdFx0cmV0W2pdID0gdG1wO1xyXG5cdFx0XHRcdGlmICghaikgYnJlYWs7XHJcblx0XHRcdFx0cHJldl9jYyA9IHVucGFja19jYyhyZXRbLS1qXSk7XHJcblx0XHRcdFx0aWYgKHByZXZfY2MgPD0gY2MpIGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHByZXZfY2MgPSB1bnBhY2tfY2MocmV0W2ldKTtcclxuXHRcdH1cclxuXHR9XHJcblx0cmV0dXJuIHJldDtcclxufVxyXG5cclxuZnVuY3Rpb24gY29tcG9zZWRfZnJvbV9kZWNvbXBvc2VkKHYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHByZXZfY3AgPSAtMTtcclxuXHRsZXQgcHJldl9jYyA9IDA7XHJcblx0Zm9yIChsZXQgcGFja2VkIG9mIHYpIHtcclxuXHRcdGxldCBjYyA9IHVucGFja19jYyhwYWNrZWQpO1xyXG5cdFx0bGV0IGNwID0gdW5wYWNrX2NwKHBhY2tlZCk7XHJcblx0XHRpZiAocHJldl9jcCA9PSAtMSkge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXQucHVzaChjcCk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSBpZiAocHJldl9jYyA+IDAgJiYgcHJldl9jYyA+PSBjYykge1xyXG5cdFx0XHRpZiAoY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3AsIC4uLnN0YWNrKTtcclxuXHRcdFx0XHRzdGFjay5sZW5ndGggPSAwO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY29tcG9zZWQgPSBjb21wb3NlX3BhaXIocHJldl9jcCwgY3ApO1xyXG5cdFx0XHRpZiAoY29tcG9zZWQgPj0gMCkge1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjb21wb3NlZDtcclxuXHRcdFx0fSBlbHNlIGlmIChwcmV2X2NjID09IDAgJiYgY2MgPT0gMCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKHByZXZfY3ApO1xyXG5cdFx0XHRcdHByZXZfY3AgPSBjcDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRzdGFjay5wdXNoKGNwKTtcclxuXHRcdFx0XHRwcmV2X2NjID0gY2M7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKHByZXZfY3AgPj0gMCkge1xyXG5cdFx0cmV0LnB1c2gocHJldl9jcCwgLi4uc3RhY2spO1x0XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbi8vIG5vdGU6IGNwcyBjYW4gYmUgaXRlcmFibGVcclxuZnVuY3Rpb24gbmZkKGNwcykge1xyXG5cdHJldHVybiBkZWNvbXBvc2VkKGNwcykubWFwKHVucGFja19jcCk7XHJcbn1cclxuZnVuY3Rpb24gbmZjKGNwcykge1xyXG5cdHJldHVybiBjb21wb3NlZF9mcm9tX2RlY29tcG9zZWQoZGVjb21wb3NlZChjcHMpKTtcclxufVxuXG4vL2NvbnN0IHQwID0gcGVyZm9ybWFuY2Uubm93KCk7XHJcblxyXG5jb25zdCBTVE9QID0gMHgyRTtcclxuY29uc3QgRkUwRiA9IDB4RkUwRjtcclxuY29uc3QgU1RPUF9DSCA9ICcuJztcclxuY29uc3QgVU5JUVVFX1BIID0gMTtcclxuY29uc3QgSFlQSEVOID0gMHgyRDtcclxuXHJcbmZ1bmN0aW9uIHJlYWRfc2V0KCkge1xyXG5cdHJldHVybiBuZXcgU2V0KHJlYWRfc29ydGVkKHIkMSkpO1xyXG59XHJcbmNvbnN0IE1BUFBFRCA9IG5ldyBNYXAocmVhZF9tYXBwZWQociQxKSk7IFxyXG5jb25zdCBJR05PUkVEID0gcmVhZF9zZXQoKTsgLy8gaWdub3JlZCBjaGFyYWN0ZXJzIGFyZSBub3QgdmFsaWQsIHNvIGp1c3QgcmVhZCByYXcgY29kZXBvaW50c1xyXG4vKlxyXG4vLyBkaXJlY3QgaW5jbHVkZSBmcm9tIHBheWxvYWQgaXMgc21hbGxlciB0aGF0IHRoZSBkZWNvbXByZXNzaW9uIGNvZGVcclxuY29uc3QgRkVOQ0VEID0gbmV3IE1hcChyZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRsZXQgY3AgPSByKCk7XHJcblx0aWYgKGNwKSByZXR1cm4gW2NwLCByZWFkX3N0cihyKCkpXTtcclxufSkpO1xyXG4qL1xyXG4vLyAyMDIzMDIxNzogd2Ugc3RpbGwgbmVlZCBhbGwgQ00gZm9yIHByb3BlciBlcnJvciBmb3JtYXR0aW5nXHJcbi8vIGJ1dCBub3JtIG9ubHkgbmVlZHMgTlNNIHN1YnNldCB0aGF0IGFyZSBwb3RlbnRpYWxseS12YWxpZFxyXG5jb25zdCBDTSA9IHJlYWRfc2V0KCk7XHJcbmNvbnN0IE5TTSA9IG5ldyBTZXQocmVhZF9zb3J0ZWQociQxKS5tYXAoZnVuY3Rpb24oaSkgeyByZXR1cm4gdGhpc1tpXTsgfSwgWy4uLkNNXSkpO1xyXG4vKlxyXG5jb25zdCBDTV9TT1JURUQgPSByZWFkX3NvcnRlZChyKTtcclxuY29uc3QgTlNNID0gbmV3IFNldChyZWFkX3NvcnRlZChyKS5tYXAoaSA9PiBDTV9TT1JURURbaV0pKTtcclxuY29uc3QgQ00gPSBuZXcgU2V0KENNX1NPUlRFRCk7XHJcbiovXHJcbmNvbnN0IEVTQ0FQRSA9IHJlYWRfc2V0KCk7IC8vIGNoYXJhY3RlcnMgdGhhdCBzaG91bGQgbm90IGJlIHByaW50ZWRcclxuY29uc3QgTkZDX0NIRUNLID0gcmVhZF9zZXQoKTtcclxuY29uc3QgQ0hVTktTID0gcmVhZF9zb3J0ZWRfYXJyYXlzKHIkMSk7XHJcbmZ1bmN0aW9uIHJlYWRfY2h1bmtlZCgpIHtcclxuXHQvLyBkZWR1cGxpY2F0ZWQgc2V0cyArIHVuaXF1ZXNcclxuXHRyZXR1cm4gbmV3IFNldChbcmVhZF9zb3J0ZWQociQxKS5tYXAoaSA9PiBDSFVOS1NbaV0pLCByZWFkX3NvcnRlZChyJDEpXS5mbGF0KDIpKTtcclxufVxyXG5jb25zdCBVTlJFU1RSSUNURUQgPSByJDEoKTtcclxuY29uc3QgR1JPVVBTID0gcmVhZF9hcnJheV93aGlsZShpID0+IHtcclxuXHQvLyBtaW5pZmllciBwcm9wZXJ0eSBtYW5nbGluZyBzZWVtcyB1bnNhZmVcclxuXHQvLyBzbyB0aGVzZSBhcmUgbWFudWFsbHkgcmVuYW1lZCB0byBzaW5nbGUgY2hhcnNcclxuXHRsZXQgTiA9IHJlYWRfYXJyYXlfd2hpbGUociQxKS5tYXAoeCA9PiB4KzB4NjApO1xyXG5cdGlmIChOLmxlbmd0aCkge1xyXG5cdFx0bGV0IFIgPSBpID49IFVOUkVTVFJJQ1RFRDsgLy8gZmlyc3QgYXJlbnQgcmVzdHJpY3RlZFxyXG5cdFx0TlswXSAtPSAzMjsgLy8gY2FwaXRhbGl6ZVxyXG5cdFx0TiA9IHN0cl9mcm9tX2NwcyhOKTtcclxuXHRcdGlmIChSKSBOPWBSZXN0cmljdGVkWyR7Tn1dYDtcclxuXHRcdGxldCBQID0gcmVhZF9jaHVua2VkKCk7IC8vIHByaW1hcnlcclxuXHRcdGxldCBRID0gcmVhZF9jaHVua2VkKCk7IC8vIHNlY29uZGFyeVxyXG5cdFx0bGV0IFYgPSBbLi4uUCwgLi4uUV0uc29ydCgoYSwgYikgPT4gYS1iKTsgLy8gZGVyaXZlOiBzb3J0ZWQgdmFsaWRcclxuXHRcdC8vbGV0IE0gPSByKCktMTsgLy8gY29tYmluaW5nIG1hcmtcclxuXHRcdGxldCBNID0gIXIkMSgpOyAvLyBub3Qtd2hpdGVsaXN0ZWQsIGNoZWNrIGZvciBOU01cclxuXHRcdC8vIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZFxyXG5cdFx0LyppZiAoTSA8IDApIHsgLy8gd2hpdGVsaXN0ZWRcclxuXHRcdFx0TSA9IG5ldyBNYXAocmVhZF9hcnJheV93aGlsZSgoKSA9PiB7XHJcblx0XHRcdFx0bGV0IGkgPSByKCk7XHJcblx0XHRcdFx0aWYgKGkpIHJldHVybiBbVltpLTFdLCByZWFkX2FycmF5X3doaWxlKCgpID0+IHtcclxuXHRcdFx0XHRcdGxldCB2ID0gcmVhZF9hcnJheV93aGlsZShyKTtcclxuXHRcdFx0XHRcdGlmICh2Lmxlbmd0aCkgcmV0dXJuIHYubWFwKHggPT4geC0xKTtcclxuXHRcdFx0XHR9KV07XHJcblx0XHRcdH0pKTtcclxuXHRcdH0qL1xyXG5cdFx0cmV0dXJuIHtOLCBQLCBNLCBSLCBWOiBuZXcgU2V0KFYpfTtcclxuXHR9XHJcbn0pO1xyXG5jb25zdCBXSE9MRV9WQUxJRCA9IHJlYWRfc2V0KCk7XHJcbmNvbnN0IFdIT0xFX01BUCA9IG5ldyBNYXAoKTtcclxuLy8gZGVjb2RlIGNvbXByZXNzZWQgd2hvbGVzXHJcblsuLi5XSE9MRV9WQUxJRCwgLi4ucmVhZF9zZXQoKV0uc29ydCgoYSwgYikgPT4gYS1iKS5tYXAoKGNwLCBpLCB2KSA9PiB7XHJcblx0bGV0IGQgPSByJDEoKTsgXHJcblx0bGV0IHcgPSB2W2ldID0gZCA/IHZbaS1kXSA6IHtWOiBbXSwgTTogbmV3IE1hcCgpfTtcclxuXHR3LlYucHVzaChjcCk7IC8vIGFkZCB0byBtZW1iZXIgc2V0XHJcblx0aWYgKCFXSE9MRV9WQUxJRC5oYXMoY3ApKSB7XHJcblx0XHRXSE9MRV9NQVAuc2V0KGNwLCB3KTsgIC8vIHJlZ2lzdGVyIHdpdGggd2hvbGUgbWFwXHJcblx0fVxyXG59KTtcclxuLy8gY29tcHV0ZSBjb25mdXNhYmxlLWV4dGVudCBjb21wbGVtZW50c1xyXG5mb3IgKGxldCB7ViwgTX0gb2YgbmV3IFNldChXSE9MRV9NQVAudmFsdWVzKCkpKSB7XHJcblx0Ly8gY29ubmVjdCBhbGwgZ3JvdXBzIHRoYXQgaGF2ZSBlYWNoIHdob2xlIGNoYXJhY3RlclxyXG5cdGxldCByZWNzID0gW107XHJcblx0Zm9yIChsZXQgY3Agb2YgVikge1xyXG5cdFx0bGV0IGdzID0gR1JPVVBTLmZpbHRlcihnID0+IGcuVi5oYXMoY3ApKTtcclxuXHRcdGxldCByZWMgPSByZWNzLmZpbmQoKHtHfSkgPT4gZ3Muc29tZShnID0+IEcuaGFzKGcpKSk7XHJcblx0XHRpZiAoIXJlYykge1xyXG5cdFx0XHRyZWMgPSB7RzogbmV3IFNldCgpLCBWOiBbXX07XHJcblx0XHRcdHJlY3MucHVzaChyZWMpO1xyXG5cdFx0fVxyXG5cdFx0cmVjLlYucHVzaChjcCk7XHJcblx0XHRncy5mb3JFYWNoKGcgPT4gcmVjLkcuYWRkKGcpKTtcclxuXHR9XHJcblx0Ly8gcGVyIGNoYXJhY3RlciBjYWNoZSBncm91cHMgd2hpY2ggYXJlIG5vdCBhIG1lbWJlciBvZiB0aGUgZXh0ZW50XHJcblx0bGV0IHVuaW9uID0gcmVjcy5mbGF0TWFwKCh7R30pID0+IFsuLi5HXSk7XHJcblx0Zm9yIChsZXQge0csIFZ9IG9mIHJlY3MpIHtcclxuXHRcdGxldCBjb21wbGVtZW50ID0gbmV3IFNldCh1bmlvbi5maWx0ZXIoZyA9PiAhRy5oYXMoZykpKTtcclxuXHRcdGZvciAobGV0IGNwIG9mIFYpIHtcclxuXHRcdFx0TS5zZXQoY3AsIGNvbXBsZW1lbnQpO1xyXG5cdFx0fVxyXG5cdH1cclxufVxyXG5sZXQgdW5pb24gPSBuZXcgU2V0KCk7IC8vIGV4aXN0cyBpbiAxKyBncm91cHNcclxubGV0IG11bHRpID0gbmV3IFNldCgpOyAvLyBleGlzdHMgaW4gMisgZ3JvdXBzXHJcbmZvciAobGV0IGcgb2YgR1JPVVBTKSB7XHJcblx0Zm9yIChsZXQgY3Agb2YgZy5WKSB7XHJcblx0XHQodW5pb24uaGFzKGNwKSA/IG11bHRpIDogdW5pb24pLmFkZChjcCk7XHJcblx0fVxyXG59XHJcbi8vIGR1YWwgcHVycG9zZSBXSE9MRV9NQVA6IHJldHVybiBwbGFjZWhvbGRlciBpZiB1bmlxdWUgbm9uLWNvbmZ1c2FibGVcclxuZm9yIChsZXQgY3Agb2YgdW5pb24pIHtcclxuXHRpZiAoIVdIT0xFX01BUC5oYXMoY3ApICYmICFtdWx0aS5oYXMoY3ApKSB7XHJcblx0XHRXSE9MRV9NQVAuc2V0KGNwLCBVTklRVUVfUEgpO1xyXG5cdH1cclxufVxyXG5jb25zdCBWQUxJRCA9IG5ldyBTZXQoWy4uLnVuaW9uLCAuLi5uZmQodW5pb24pXSk7IC8vIHBvc3NpYmx5IHZhbGlkXHJcblxyXG4vLyBkZWNvZGUgZW1vamlcclxuY29uc3QgRU1PSklfU09SVEVEID0gcmVhZF9zb3J0ZWQociQxKTsgLy8gdGVtcG9yYXJ5XHJcbi8vY29uc3QgRU1PSklfU09MTyA9IG5ldyBTZXQocmVhZF9zb3J0ZWQocikubWFwKGkgPT4gRU1PSklfU09SVEVEW2ldKSk7IC8vIG5vdCBuZWVkZWRcclxuY29uc3QgRU1PSklfUk9PVCA9IHJlYWRfZW1vamlfdHJpZShbXSk7XHJcbmZ1bmN0aW9uIHJlYWRfZW1vamlfdHJpZShjcHMpIHtcclxuXHRsZXQgQiA9IHJlYWRfYXJyYXlfd2hpbGUoKCkgPT4ge1xyXG5cdFx0bGV0IGtleXMgPSByZWFkX3NvcnRlZChyJDEpLm1hcChpID0+IEVNT0pJX1NPUlRFRFtpXSk7XHJcblx0XHRpZiAoa2V5cy5sZW5ndGgpIHJldHVybiByZWFkX2Vtb2ppX3RyaWUoa2V5cyk7XHJcblx0fSkuc29ydCgoYSwgYikgPT4gYi5RLnNpemUgLSBhLlEuc2l6ZSk7IC8vIHNvcnQgYnkgbGlrZWxpaG9vZFxyXG5cdGxldCB0ZW1wID0gciQxKCk7XHJcblx0bGV0IFYgPSB0ZW1wICUgMzsgLy8gdmFsaWQgKDAgPSBmYWxzZSwgMSA9IHRydWUsIDIgPSB3ZWlyZClcclxuXHR0ZW1wID0gKHRlbXAgLyAzKXwwO1xyXG5cdGxldCBGID0gdGVtcCAmIDE7IC8vIGFsbG93IEZFMEZcclxuXHR0ZW1wID4+PSAxO1xyXG5cdGxldCBTID0gdGVtcCAmIDE7IC8vIHNhdmVcclxuXHRsZXQgQyA9IHRlbXAgJiAyOyAvLyBjaGVja1xyXG5cdHJldHVybiB7QiwgViwgRiwgUywgQywgUTogbmV3IFNldChjcHMpfTtcclxufVxyXG4vL2NvbnNvbGUubG9nKHBlcmZvcm1hbmNlLm5vdygpIC0gdDApO1xyXG5cclxuLy8gZnJlZSB0YWdnaW5nIHN5c3RlbVxyXG5jbGFzcyBFbW9qaSBleHRlbmRzIEFycmF5IHtcclxuXHRnZXQgaXNfZW1vamkoKSB7IHJldHVybiB0cnVlOyB9XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIHNhZmUgdG8gcHJpbnQgc3RyaW5nIFxyXG4vLyBpbnZpc2libGVzIGFyZSBlc2NhcGVkXHJcbi8vIGxlYWRpbmcgY20gdXNlcyBwbGFjZWhvbGRlclxyXG4vLyBxdW90ZXIoY3ApID0+IHN0cmluZywgZWcuIDMwMDAgPT4gXCJ7MzAwMH1cIlxyXG4vLyBub3RlOiBpbiBodG1sLCB5b3UnZCBjYWxsIHRoaXMgZnVuY3Rpb24gdGhlbiByZXBsYWNlIFs8PiZdIHdpdGggZW50aXRpZXNcclxuZnVuY3Rpb24gc2FmZV9zdHJfZnJvbV9jcHMoY3BzLCBxdW90ZXIgPSBxdW90ZV9jcCkge1xyXG5cdC8vaWYgKE51bWJlci5pc0ludGVnZXIoY3BzKSkgY3BzID0gW2Nwc107XHJcblx0Ly9pZiAoIUFycmF5LmlzQXJyYXkoY3BzKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihgZXhwZWN0ZWQgY29kZXBvaW50c2ApO1xyXG5cdGxldCBidWYgPSBbXTtcclxuXHRpZiAoaXNfY29tYmluaW5nX21hcmsoY3BzWzBdKSkgYnVmLnB1c2goJ+KXjCcpO1xyXG5cdGxldCBwcmV2ID0gMDtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuOyBpKyspIHtcclxuXHRcdGxldCBjcCA9IGNwc1tpXTtcclxuXHRcdGlmIChzaG91bGRfZXNjYXBlKGNwKSkge1xyXG5cdFx0XHRidWYucHVzaChzdHJfZnJvbV9jcHMoY3BzLnNsaWNlKHByZXYsIGkpKSk7XHJcblx0XHRcdGJ1Zi5wdXNoKHF1b3RlcihjcCkpO1xyXG5cdFx0XHRwcmV2ID0gaSArIDE7XHJcblx0XHR9XHJcblx0fVxyXG5cdGJ1Zi5wdXNoKHN0cl9mcm9tX2NwcyhjcHMuc2xpY2UocHJldiwgbikpKTtcclxuXHRyZXR1cm4gYnVmLmpvaW4oJycpO1xyXG59XHJcblxyXG4vLyBpZiBlc2NhcGVkOiB7SEVYfVxyXG4vLyAgICAgICBlbHNlOiBcInhcIiB7SEVYfVxyXG5mdW5jdGlvbiBxdW90ZWRfY3AoY3ApIHtcclxuXHRyZXR1cm4gKHNob3VsZF9lc2NhcGUoY3ApID8gJycgOiBgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKFtjcF0pKX0gYCkgKyBxdW90ZV9jcChjcCk7XHJcbn1cclxuXHJcbi8vIDIwMjMwMjExOiBzb21lIG1lc3NhZ2VzIGNhbiBiZSBtaXhlZC1kaXJlY3Rpb25hbCBhbmQgcmVzdWx0IGluIHNwaWxsb3ZlclxyXG4vLyB1c2UgMjAwRSBhZnRlciBhIHF1b3RlZCBzdHJpbmcgdG8gZm9yY2UgdGhlIHJlbWFpbmRlciBvZiBhIHN0cmluZyBmcm9tIFxyXG4vLyBhY3F1cmluZyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBxdW90ZVxyXG4vLyBodHRwczovL3d3dy53My5vcmcvSW50ZXJuYXRpb25hbC9xdWVzdGlvbnMvcWEtYmlkaS11bmljb2RlLWNvbnRyb2xzI2V4Y2VwdGlvbnNcclxuZnVuY3Rpb24gYmlkaV9xcShzKSB7XHJcblx0cmV0dXJuIGBcIiR7c31cIlxcdTIwMEVgOyAvLyBzdHJvbmcgTFRSXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrX2xhYmVsX2V4dGVuc2lvbihjcHMpIHtcclxuXHRpZiAoY3BzLmxlbmd0aCA+PSA0ICYmIGNwc1syXSA9PSBIWVBIRU4gJiYgY3BzWzNdID09IEhZUEhFTikge1xyXG5cdFx0dGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGxhYmVsIGV4dGVuc2lvbicpO1xyXG5cdH1cclxufVxyXG5mdW5jdGlvbiBjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUoY3BzKSB7XHJcblx0Y29uc3QgVU5ERVJTQ09SRSA9IDB4NUY7XHJcblx0Zm9yIChsZXQgaSA9IGNwcy5sYXN0SW5kZXhPZihVTkRFUlNDT1JFKTsgaSA+IDA7ICkge1xyXG5cdFx0aWYgKGNwc1stLWldICE9PSBVTkRFUlNDT1JFKSB7XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcigndW5kZXJzY29yZSBhbGxvd2VkIG9ubHkgYXQgc3RhcnQnKTtcclxuXHRcdH1cclxuXHR9XHJcbn1cclxuLy8gY2hlY2sgdGhhdCBhIGZlbmNlZCBjcCBpcyBub3QgbGVhZGluZywgdHJhaWxpbmcsIG9yIHRvdWNoaW5nIGFub3RoZXIgZmVuY2VkIGNwXHJcbmZ1bmN0aW9uIGNoZWNrX2ZlbmNlZChjcHMpIHtcclxuXHRsZXQgY3AgPSBjcHNbMF07XHJcblx0bGV0IHByZXYgPSBGRU5DRUQuZ2V0KGNwKTtcclxuXHRpZiAocHJldikgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGBsZWFkaW5nICR7cHJldn1gKTtcclxuXHRsZXQgbiA9IGNwcy5sZW5ndGg7XHJcblx0bGV0IGxhc3QgPSAtMTsgLy8gcHJldmVudHMgdHJhaWxpbmcgZnJvbSB0aHJvd2luZ1xyXG5cdGZvciAobGV0IGkgPSAxOyBpIDwgbjsgaSsrKSB7XHJcblx0XHRjcCA9IGNwc1tpXTtcclxuXHRcdGxldCBtYXRjaCA9IEZFTkNFRC5nZXQoY3ApO1xyXG5cdFx0aWYgKG1hdGNoKSB7XHJcblx0XHRcdC8vIHNpbmNlIGNwc1swXSBpc24ndCBmZW5jZWQsIGNwc1sxXSBjYW5ub3QgdGhyb3dcclxuXHRcdFx0aWYgKGxhc3QgPT0gaSkgdGhyb3cgZXJyb3JfcGxhY2VtZW50KGAke3ByZXZ9ICsgJHttYXRjaH1gKTtcclxuXHRcdFx0bGFzdCA9IGkgKyAxO1xyXG5cdFx0XHRwcmV2ID0gbWF0Y2g7XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChsYXN0ID09IG4pIHRocm93IGVycm9yX3BsYWNlbWVudChgdHJhaWxpbmcgJHtwcmV2fWApO1xyXG59XHJcblxyXG4vLyBub3RlOiBzZXQocykgY2Fubm90IGJlIGV4cG9zZWQgYmVjYXVzZSB0aGV5IGNhbiBiZSBtb2RpZmllZFxyXG5mdW5jdGlvbiBpc19jb21iaW5pbmdfbWFyayhjcCkge1xyXG5cdHJldHVybiBDTS5oYXMoY3ApO1xyXG59XHJcbmZ1bmN0aW9uIHNob3VsZF9lc2NhcGUoY3ApIHtcclxuXHRyZXR1cm4gRVNDQVBFLmhhcyhjcCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemVfZnJhZ21lbnQoZnJhZywgZGVjb21wb3NlKSB7XHJcblx0bGV0IG5mID0gZGVjb21wb3NlID8gbmZkIDogbmZjO1xyXG5cdHJldHVybiBmcmFnLnNwbGl0KFNUT1BfQ0gpLm1hcChsYWJlbCA9PiBzdHJfZnJvbV9jcHMocHJvY2VzcyhleHBsb2RlX2NwKGxhYmVsKSwgbmYpLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gZmlsdGVyX2ZlMGYoeCkgOiB4KSkpLmpvaW4oU1RPUF9DSCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19ub3JtYWxpemUobmFtZSkge1xyXG5cdHJldHVybiBmbGF0dGVuKGVuc19zcGxpdChuYW1lKSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGVuc19iZWF1dGlmeShuYW1lKSB7XHJcblx0bGV0IHNwbGl0ID0gZW5zX3NwbGl0KG5hbWUsIHRydWUpO1xyXG5cdC8vIHRoaXMgaXMgZXhwZXJpbWVudGFsXHJcblx0Zm9yIChsZXQge3R5cGUsIG91dHB1dCwgZXJyb3J9IG9mIHNwbGl0KSB7XHJcblx0XHRpZiAoZXJyb3IpIGNvbnRpbnVlO1xyXG5cclxuXHRcdC8vIHJlcGxhY2UgbGVhZGluZy90cmFpbGluZyBoeXBoZW5cclxuXHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBiZWF1dGlmaW5nIGFsbCBvciBsZWFkaW5nL3RyYWlsaW5nIGh5cGhlbiB0byB1bmljb2RlIHZhcmlhbnRcclxuXHRcdC8vIG5vdCBleGFjdGx5IHRoZSBzYW1lIGluIGV2ZXJ5IGZvbnQsIGJ1dCB2ZXJ5IHNpbWlsYXI6IFwiLVwiIHZzIFwi4oCQXCJcclxuXHRcdC8qXHJcblx0XHRjb25zdCBVTklDT0RFX0hZUEhFTiA9IDB4MjAxMDtcclxuXHRcdC8vIG1heWJlIHRoaXMgc2hvdWxkIHJlcGxhY2UgYWxsIGZvciB2aXN1YWwgY29uc2lzdGFuY3k/XHJcblx0XHQvLyBgbm9kZSB0b29scy9yZWctY291bnQuanMgcmVnZXggXi1cXHsyLFxcfWAgPT4gNTkyXHJcblx0XHQvL2ZvciAobGV0IGkgPSAwOyBpIDwgb3V0cHV0Lmxlbmd0aDsgaSsrKSBpZiAob3V0cHV0W2ldID09IDB4MkQpIG91dHB1dFtpXSA9IDB4MjAxMDtcclxuXHRcdGlmIChvdXRwdXRbMF0gPT0gSFlQSEVOKSBvdXRwdXRbMF0gPSBVTklDT0RFX0hZUEhFTjtcclxuXHRcdGxldCBlbmQgPSBvdXRwdXQubGVuZ3RoLTE7XHJcblx0XHRpZiAob3V0cHV0W2VuZF0gPT0gSFlQSEVOKSBvdXRwdXRbZW5kXSA9IFVOSUNPREVfSFlQSEVOO1xyXG5cdFx0Ki9cclxuXHRcdC8vIDIwMjMwMTIzOiBXSEFUV0cgVVJMIHVzZXMgXCJDaGVja0h5cGhlbnNcIiBmYWxzZVxyXG5cdFx0Ly8gaHR0cHM6Ly91cmwuc3BlYy53aGF0d2cub3JnLyNpZG5hXHJcblxyXG5cdFx0Ly8gdXBkYXRlIGV0aGVyZXVtIHN5bWJvbFxyXG5cdFx0Ly8gzr4gPT4gzp4gaWYgbm90IGdyZWVrXHJcblx0XHRpZiAodHlwZSAhPT0gJ0dyZWVrJykgeyBcclxuXHRcdFx0bGV0IHByZXYgPSAwO1xyXG5cdFx0XHR3aGlsZSAodHJ1ZSkge1xyXG5cdFx0XHRcdGxldCBuZXh0ID0gb3V0cHV0LmluZGV4T2YoMHgzQkUsIHByZXYpO1xyXG5cdFx0XHRcdGlmIChuZXh0IDwgMCkgYnJlYWs7XHJcblx0XHRcdFx0b3V0cHV0W25leHRdID0gMHgzOUU7IFxyXG5cdFx0XHRcdHByZXYgPSBuZXh0ICsgMTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIDIwMjIxMjEzOiBmaXhlcyBiaWRpIHN1YmRvbWFpbiBpc3N1ZSwgYnV0IGJyZWFrcyBpbnZhcmlhbnQgKDIwMEUgaXMgZGlzYWxsb3dlZClcclxuXHRcdC8vIGNvdWxkIGJlIGZpeGVkIHdpdGggc3BlY2lhbCBjYXNlIGZvcjogMkQgKC4pICsgMjAwRSAoTFRSKVxyXG5cdFx0Ly9vdXRwdXQuc3BsaWNlKDAsIDAsIDB4MjAwRSk7XHJcblx0fVxyXG5cdHJldHVybiBmbGF0dGVuKHNwbGl0KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZW5zX3NwbGl0KG5hbWUsIHByZXNlcnZlX2Vtb2ppKSB7XHJcblx0bGV0IG9mZnNldCA9IDA7XHJcblx0Ly8gaHR0cHM6Ly91bmljb2RlLm9yZy9yZXBvcnRzL3RyNDYvI1ZhbGlkaXR5X0NyaXRlcmlhXHJcblx0Ly8gNC4pIFwiVGhlIGxhYmVsIG11c3Qgbm90IGNvbnRhaW4gYSBVKzAwMkUgKCAuICkgRlVMTCBTVE9QLlwiXHJcblx0cmV0dXJuIG5hbWUuc3BsaXQoU1RPUF9DSCkubWFwKGxhYmVsID0+IHtcclxuXHRcdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobGFiZWwpO1xyXG5cdFx0bGV0IGluZm8gPSB7XHJcblx0XHRcdGlucHV0LFxyXG5cdFx0XHRvZmZzZXQsIC8vIGNvZGVwb2ludCwgbm90IHN1YnN0cmluZyFcclxuXHRcdH07XHJcblx0XHRvZmZzZXQgKz0gaW5wdXQubGVuZ3RoICsgMTsgLy8gKyBzdG9wXHJcblx0XHRsZXQgbm9ybTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdC8vIDEuKSBcIlRoZSBsYWJlbCBtdXN0IGJlIGluIFVuaWNvZGUgTm9ybWFsaXphdGlvbiBGb3JtIE5GQ1wiXHJcblx0XHRcdGxldCB0b2tlbnMgPSBpbmZvLnRva2VucyA9IHByb2Nlc3MoaW5wdXQsIG5mYyk7IC8vIGlmIHdlIHBhcnNlLCB3ZSBnZXQgW25vcm0gYW5kIG1hcHBlZF1cclxuXHRcdFx0bGV0IHRva2VuX2NvdW50ID0gdG9rZW5zLmxlbmd0aDtcclxuXHRcdFx0bGV0IHR5cGU7XHJcblx0XHRcdGlmICghdG9rZW5fY291bnQpIHsgLy8gdGhlIGxhYmVsIHdhcyBlZmZlY3RpdmVseSBlbXB0eSAoY291bGQgb2YgaGFkIGlnbm9yZWQgY2hhcmFjdGVycylcclxuXHRcdFx0XHQvLyAyMDIzMDEyMDogY2hhbmdlIHRvIHN0cmljdFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vZGlzY3Vzcy5lbnMuZG9tYWlucy90L2Vucy1uYW1lLW5vcm1hbGl6YXRpb24tMm5kLzE0NTY0LzU5XHJcblx0XHRcdFx0Ly9ub3JtID0gW107XHJcblx0XHRcdFx0Ly90eXBlID0gJ05vbmUnOyAvLyB1c2UgdGhpcyBpbnN0ZWFkIG9mIG5leHQgbWF0Y2gsIFwiQVNDSUlcIlxyXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihgZW1wdHkgbGFiZWxgKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY2hhcnMgPSB0b2tlbnNbMF07XHJcblx0XHRcdFx0bGV0IGVtb2ppID0gdG9rZW5fY291bnQgPiAxIHx8IGNoYXJzLmlzX2Vtb2ppO1xyXG5cdFx0XHRcdGlmICghZW1vamkgJiYgY2hhcnMuZXZlcnkoY3AgPT4gY3AgPCAweDgwKSkgeyAvLyBzcGVjaWFsIGNhc2UgZm9yIGFzY2lpXHJcblx0XHRcdFx0XHRub3JtID0gY2hhcnM7XHJcblx0XHRcdFx0XHRjaGVja19sZWFkaW5nX3VuZGVyc2NvcmUobm9ybSk7XHJcblx0XHRcdFx0XHQvLyBvbmx5IG5lZWRlZCBmb3IgYXNjaWlcclxuXHRcdFx0XHRcdC8vIDIwMjMwMTIzOiBtYXRjaGVzIG1hdGNoZXMgV0hBVFdHLCBzZWUgbm90ZSAzLjNcclxuXHRcdFx0XHRcdGNoZWNrX2xhYmVsX2V4dGVuc2lvbihub3JtKTtcclxuXHRcdFx0XHRcdC8vIGNhbnQgaGF2ZSBmZW5jZWRcclxuXHRcdFx0XHRcdC8vIGNhbnQgaGF2ZSBjbVxyXG5cdFx0XHRcdFx0Ly8gY2FudCBoYXZlIHdob2xlc1xyXG5cdFx0XHRcdFx0Ly8gc2VlIGRlcml2ZTogXCJGYXN0cGF0aCBBU0NJSVwiXHJcblx0XHRcdFx0XHR0eXBlID0gJ0FTQ0lJJztcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0aWYgKGVtb2ppKSB7IC8vIHRoZXJlIGlzIGF0IGxlYXN0IG9uZSBlbW9qaVxyXG5cdFx0XHRcdFx0XHRpbmZvLmVtb2ppID0gdHJ1ZTsgXHJcblx0XHRcdFx0XHRcdGNoYXJzID0gdG9rZW5zLmZsYXRNYXAoeCA9PiB4LmlzX2Vtb2ppID8gW10gOiB4KTsgLy8gYWxsIG9mIHRoZSBuZmMgdG9rZW5zIGNvbmNhdCB0b2dldGhlclxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0bm9ybSA9IHRva2Vucy5mbGF0TWFwKHggPT4gIXByZXNlcnZlX2Vtb2ppICYmIHguaXNfZW1vamkgPyBmaWx0ZXJfZmUwZih4KSA6IHgpO1xyXG5cdFx0XHRcdFx0Y2hlY2tfbGVhZGluZ191bmRlcnNjb3JlKG5vcm0pO1xyXG5cdFx0XHRcdFx0aWYgKCFjaGFycy5sZW5ndGgpIHsgLy8gdGhlcmVzIG5vIHRleHQsIGp1c3QgZW1vamlcclxuXHRcdFx0XHRcdFx0dHlwZSA9ICdFbW9qaSc7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvLyA1LiBcIlRoZSBsYWJlbCBtdXN0IG5vdCBiZWdpbiB3aXRoIGEgY29tYmluaW5nIG1hcmssIHRoYXQgaXM6IEdlbmVyYWxfQ2F0ZWdvcnk9TWFyay5cIlxyXG5cdFx0XHRcdFx0XHRpZiAoQ00uaGFzKG5vcm1bMF0pKSB0aHJvdyBlcnJvcl9wbGFjZW1lbnQoJ2xlYWRpbmcgY29tYmluaW5nIG1hcmsnKTtcclxuXHRcdFx0XHRcdFx0Zm9yIChsZXQgaSA9IDE7IGkgPCB0b2tlbl9jb3VudDsgaSsrKSB7IC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCB0aGUgZmlyc3QgdG9rZW5cclxuXHRcdFx0XHRcdFx0XHRsZXQgY3BzID0gdG9rZW5zW2ldO1xyXG5cdFx0XHRcdFx0XHRcdGlmICghY3BzLmlzX2Vtb2ppICYmIENNLmhhcyhjcHNbMF0pKSB7IC8vIGV2ZXJ5IHRleHQgdG9rZW4gaGFzIGVtb2ppIG5laWdoYm9ycywgZWcuIEV0RUVFdEV0Li4uXHJcblx0XHRcdFx0XHRcdFx0XHQvLyBiaWRpX3FxKCkgbm90IG5lZWRlZCBzaW5jZSBlbW9qaSBpcyBMVFIgYW5kIGNwcyBpcyBhIENNXHJcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBlcnJvcl9wbGFjZW1lbnQoYGVtb2ppICsgY29tYmluaW5nIG1hcms6IFwiJHtzdHJfZnJvbV9jcHModG9rZW5zW2ktMV0pfSArICR7c2FmZV9zdHJfZnJvbV9jcHMoW2Nwc1swXV0pfVwiYCk7IFxyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjaGVja19mZW5jZWQobm9ybSk7XHJcblx0XHRcdFx0XHRcdGxldCB1bmlxdWUgPSBbLi4ubmV3IFNldChjaGFycyldO1xyXG5cdFx0XHRcdFx0XHRsZXQgW2ddID0gZGV0ZXJtaW5lX2dyb3VwKHVuaXF1ZSk7IC8vIHRha2UgdGhlIGZpcnN0IG1hdGNoXHJcblx0XHRcdFx0XHRcdC8vIHNlZSBkZXJpdmU6IFwiTWF0Y2hpbmcgR3JvdXBzIGhhdmUgU2FtZSBDTSBTdHlsZVwiXHJcblx0XHRcdFx0XHRcdC8vIGFsdGVybmF0aXZlOiBjb3VsZCBmb3JtIGEgaHlicmlkIHR5cGU6IExhdGluL0phcGFuZXNlLy4uLlx0XHJcblx0XHRcdFx0XHRcdGNoZWNrX2dyb3VwKGcsIGNoYXJzKTsgLy8gbmVlZCB0ZXh0IGluIG9yZGVyXHJcblx0XHRcdFx0XHRcdGNoZWNrX3dob2xlKGcsIHVuaXF1ZSk7IC8vIG9ubHkgbmVlZCB1bmlxdWUgdGV4dCAob3JkZXIgd291bGQgYmUgcmVxdWlyZWQgZm9yIG11bHRpcGxlLWNoYXIgY29uZnVzYWJsZXMpXHJcblx0XHRcdFx0XHRcdHR5cGUgPSBnLk47XHJcblx0XHRcdFx0XHRcdC8vIDIwMjMwMTIxOiBjb25zaWRlciBleHBvc2luZyByZXN0cmljdGVkIGZsYWdcclxuXHRcdFx0XHRcdFx0Ly8gaXQncyBzaW1wbGVyIHRvIGp1c3QgY2hlY2sgZm9yICdSZXN0cmljdGVkJ1xyXG5cdFx0XHRcdFx0XHQvLyBvciBldmVuIGJldHRlcjogdHlwZS5lbmRzV2l0aCgnXScpXHJcblx0XHRcdFx0XHRcdC8vaWYgKGcuUikgaW5mby5yZXN0cmljdGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aW5mby50eXBlID0gdHlwZTtcclxuXHRcdH0gY2F0Y2ggKGVycikge1xyXG5cdFx0XHRpbmZvLmVycm9yID0gZXJyOyAvLyB1c2UgZnVsbCBlcnJvciBvYmplY3RcclxuXHRcdH1cclxuXHRcdGluZm8ub3V0cHV0ID0gbm9ybTtcclxuXHRcdHJldHVybiBpbmZvO1xyXG5cdH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBjaGVja193aG9sZShncm91cCwgdW5pcXVlKSB7XHJcblx0bGV0IG1ha2VyO1xyXG5cdGxldCBzaGFyZWQgPSBbXTsgLy8gVE9ETzogY2FuIHRoaXMgYmUgYXZvaWRlZD9cclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdGxldCB3aG9sZSA9IFdIT0xFX01BUC5nZXQoY3ApO1xyXG5cdFx0aWYgKHdob2xlID09PSBVTklRVUVfUEgpIHJldHVybjsgLy8gdW5pcXVlLCBub24tY29uZnVzYWJsZVxyXG5cdFx0aWYgKHdob2xlKSB7XHJcblx0XHRcdGxldCBzZXQgPSB3aG9sZS5NLmdldChjcCk7IC8vIGdyb3VwcyB3aGljaCBoYXZlIGEgY2hhcmFjdGVyIHRoYXQgbG9vay1saWtlIHRoaXMgY2hhcmFjdGVyXHJcblx0XHRcdG1ha2VyID0gbWFrZXIgPyBtYWtlci5maWx0ZXIoZyA9PiBzZXQuaGFzKGcpKSA6IFsuLi5zZXRdO1xyXG5cdFx0XHRpZiAoIW1ha2VyLmxlbmd0aCkgcmV0dXJuOyAvLyBjb25mdXNhYmxlIGludGVyc2VjdGlvbiBpcyBlbXB0eVxyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0c2hhcmVkLnB1c2goY3ApOyBcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKG1ha2VyKSB7XHJcblx0XHQvLyB3ZSBoYXZlIDErIGNvbmZ1c2FibGVcclxuXHRcdC8vIGNoZWNrIGlmIGFueSBvZiB0aGUgcmVtYW5pbmcgZ3JvdXBzXHJcblx0XHQvLyBjb250YWluIHRoZSBzaGFyZWQgY2hhcmFjdGVycyB0b29cclxuXHRcdGZvciAobGV0IGcgb2YgbWFrZXIpIHtcclxuXHRcdFx0aWYgKHNoYXJlZC5ldmVyeShjcCA9PiBnLlYuaGFzKGNwKSkpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYHdob2xlLXNjcmlwdCBjb25mdXNhYmxlOiAke2dyb3VwLk59LyR7Zy5OfWApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyBhc3N1bXB0aW9uOiB1bmlxdWUuc2l6ZSA+IDBcclxuLy8gcmV0dXJucyBsaXN0IG9mIG1hdGNoaW5nIGdyb3Vwc1xyXG5mdW5jdGlvbiBkZXRlcm1pbmVfZ3JvdXAodW5pcXVlKSB7XHJcblx0bGV0IGdyb3VwcyA9IEdST1VQUztcclxuXHRmb3IgKGxldCBjcCBvZiB1bmlxdWUpIHtcclxuXHRcdC8vIG5vdGU6IHdlIG5lZWQgdG8gZG9kZ2UgQ00gdGhhdCBhcmUgd2hpdGVsaXN0ZWRcclxuXHRcdC8vIGJ1dCB0aGF0IGNvZGUgaXNuJ3QgY3VycmVudGx5IG5lY2Vzc2FyeVxyXG5cdFx0bGV0IGdzID0gZ3JvdXBzLmZpbHRlcihnID0+IGcuVi5oYXMoY3ApKTtcclxuXHRcdGlmICghZ3MubGVuZ3RoKSB7XHJcblx0XHRcdGlmIChncm91cHMgPT09IEdST1VQUykge1xyXG5cdFx0XHRcdC8vIHRoZSBjaGFyYWN0ZXIgd2FzIGNvbXBvc2VkIG9mIHZhbGlkIHBhcnRzXHJcblx0XHRcdFx0Ly8gYnV0IGl0J3MgTkZDIGZvcm0gaXMgaW52YWxpZFxyXG5cdFx0XHRcdHRocm93IGVycm9yX2Rpc2FsbG93ZWQoY3ApOyAvLyB0aGlzIHNob3VsZCBiZSByYXJlXHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Ly8gdGhlcmUgaXMgbm8gZ3JvdXAgdGhhdCBjb250YWlucyBhbGwgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdFx0XHRcdC8vIHRocm93IHVzaW5nIHRoZSBoaWdoZXN0IHByaW9yaXR5IGdyb3VwIHRoYXQgbWF0Y2hlZFxyXG5cdFx0XHRcdC8vIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL3JlcG9ydHMvdHIzOS8jbWl4ZWRfc2NyaXB0X2NvbmZ1c2FibGVzXHJcblx0XHRcdFx0dGhyb3cgZXJyb3JfZ3JvdXBfbWVtYmVyKGdyb3Vwc1swXSwgY3ApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRncm91cHMgPSBncztcclxuXHRcdGlmIChncy5sZW5ndGggPT0gMSkgYnJlYWs7IC8vIHRoZXJlIGlzIG9ubHkgb25lIGdyb3VwIGxlZnRcclxuXHR9XHJcblx0Ly8gdGhlcmUgYXJlIGF0IGxlYXN0IDEgZ3JvdXAocykgd2l0aCBhbGwgb2YgdGhlc2UgY2hhcmFjdGVyc1xyXG5cdHJldHVybiBncm91cHM7XHJcbn1cclxuXHJcbi8vIHRocm93IG9uIGZpcnN0IGVycm9yXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oc3BsaXQpIHtcclxuXHRyZXR1cm4gc3BsaXQubWFwKCh7aW5wdXQsIGVycm9yLCBvdXRwdXR9KSA9PiB7XHJcblx0XHRpZiAoZXJyb3IpIHtcclxuXHRcdFx0Ly8gZG9uJ3QgcHJpbnQgbGFiZWwgYWdhaW4gaWYganVzdCBhIHNpbmdsZSBsYWJlbFxyXG5cdFx0XHRsZXQgbXNnID0gZXJyb3IubWVzc2FnZTtcclxuXHRcdFx0Ly8gYmlkaV9xcSgpIG9ubHkgbmVjZXNzYXJ5IGlmIG1zZyBpcyBkaWdpdHNcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKHNwbGl0Lmxlbmd0aCA9PSAxID8gbXNnIDogYEludmFsaWQgbGFiZWwgJHtiaWRpX3FxKHNhZmVfc3RyX2Zyb21fY3BzKGlucHV0KSl9OiAke21zZ31gKTsgXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyX2Zyb21fY3BzKG91dHB1dCk7XHJcblx0fSkuam9pbihTVE9QX0NIKTtcclxufVxyXG5cclxuZnVuY3Rpb24gZXJyb3JfZGlzYWxsb3dlZChjcCkge1xyXG5cdC8vIFRPRE86IGFkZCBjcCB0byBlcnJvcj9cclxuXHRyZXR1cm4gbmV3IEVycm9yKGBkaXNhbGxvd2VkIGNoYXJhY3RlcjogJHtxdW90ZWRfY3AoY3ApfWApOyBcclxufVxyXG5mdW5jdGlvbiBlcnJvcl9ncm91cF9tZW1iZXIoZywgY3ApIHtcclxuXHRsZXQgcXVvdGVkID0gcXVvdGVkX2NwKGNwKTtcclxuXHRsZXQgZ2cgPSBHUk9VUFMuZmluZChnID0+IGcuUC5oYXMoY3ApKTtcclxuXHRpZiAoZ2cpIHtcclxuXHRcdHF1b3RlZCA9IGAke2dnLk59ICR7cXVvdGVkfWA7XHJcblx0fVxyXG5cdHJldHVybiBuZXcgRXJyb3IoYGlsbGVnYWwgbWl4dHVyZTogJHtnLk59ICsgJHtxdW90ZWR9YCk7XHJcbn1cclxuZnVuY3Rpb24gZXJyb3JfcGxhY2VtZW50KHdoZXJlKSB7XHJcblx0cmV0dXJuIG5ldyBFcnJvcihgaWxsZWdhbCBwbGFjZW1lbnQ6ICR7d2hlcmV9YCk7XHJcbn1cclxuXHJcbi8vIGFzc3VtcHRpb246IGNwcy5sZW5ndGggPiAwXHJcbi8vIGFzc3VtcHRpb246IGNwc1swXSBpc24ndCBhIENNXHJcbi8vIGFzc3VtcHRpb246IHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIgaXNuJ3QgYW4gZW1vamlcclxuZnVuY3Rpb24gY2hlY2tfZ3JvdXAoZywgY3BzKSB7XHJcblx0bGV0IHtWLCBNfSA9IGc7XHJcblx0Zm9yIChsZXQgY3Agb2YgY3BzKSB7XHJcblx0XHRpZiAoIVYuaGFzKGNwKSkge1xyXG5cdFx0XHQvLyBmb3Igd2hpdGVsaXN0ZWQgc2NyaXB0cywgdGhpcyB3aWxsIHRocm93IGlsbGVnYWwgbWl4dHVyZSBvbiBpbnZhbGlkIGNtLCBlZy4gXCJlezMwMH17MzAwfVwiXHJcblx0XHRcdC8vIGF0IHRoZSBtb21lbnQsIGl0J3MgdW5uZWNlc3NhcnkgdG8gaW50cm9kdWNlIGFuIGV4dHJhIGVycm9yIHR5cGVcclxuXHRcdFx0Ly8gdW50aWwgdGhlcmUgZXhpc3RzIGEgd2hpdGVsaXN0ZWQgbXVsdGktY2hhcmFjdGVyXHJcblx0XHRcdC8vICAgZWcuIGlmIChNIDwgMCAmJiBpc19jb21iaW5pbmdfbWFyayhjcCkpIHsgLi4uIH1cclxuXHRcdFx0Ly8gdGhlcmUgYXJlIDMgY2FzZXM6XHJcblx0XHRcdC8vICAgMS4gaWxsZWdhbCBjbSBmb3Igd3JvbmcgZ3JvdXAgPT4gbWl4dHVyZSBlcnJvclxyXG5cdFx0XHQvLyAgIDIuIGlsbGVnYWwgY20gZm9yIHNhbWUgZ3JvdXAgPT4gY20gZXJyb3JcclxuXHRcdFx0Ly8gICAgICAgcmVxdWlyZXMgc2V0IG9mIHdoaXRlbGlzdCBjbSBwZXIgZ3JvdXA6IFxyXG5cdFx0XHQvLyAgICAgICAgZWcuIG5ldyBTZXQoWy4uLmcuVl0uZmxhdE1hcChuZmMpLmZpbHRlcihjcCA9PiBDTS5oYXMoY3ApKSlcclxuXHRcdFx0Ly8gICAzLiB3cm9uZyBncm91cCA9PiBtaXh0dXJlIGVycm9yXHJcblx0XHRcdHRocm93IGVycm9yX2dyb3VwX21lbWJlcihnLCBjcCk7XHJcblx0XHR9XHJcblx0fVxyXG5cdC8vaWYgKE0gPj0gMCkgeyAvLyB3ZSBoYXZlIGEga25vd24gZml4ZWQgY20gY291bnRcclxuXHRpZiAoTSkgeyAvLyB3ZSBuZWVkIHRvIGNoZWNrIGZvciBOU01cclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHNlZTogYXNzdW1wdGlvblxyXG5cdFx0XHQvLyAyMDIzMDIxMDogYnVnZml4OiB1c2luZyBjcHMgaW5zdGVhZCBvZiBkZWNvbXBvc2VkIGgvdCBDYXJib24yMjVcclxuXHRcdFx0LypcclxuXHRcdFx0aWYgKENNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhkZWNvbXBvc2VkW2pdKSkgaisrO1xyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE0pIHtcclxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgdG9vIG1hbnkgY29tYmluaW5nIG1hcmtzOiAke2cuTn0gJHtiaWRpX3FxKHN0cl9mcm9tX2NwcyhkZWNvbXBvc2VkLnNsaWNlKGktMSwgaikpKX0gKCR7ai1pfS8ke019KWApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpID0gajtcclxuXHRcdFx0fVxyXG5cdFx0XHQqL1xyXG5cdFx0XHQvLyAyMDIzMDIxNzogc3dpdGNoIHRvIE5TTSBjb3VudGluZ1xyXG5cdFx0XHQvLyBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMzkvI09wdGlvbmFsX0RldGVjdGlvblxyXG5cdFx0XHRpZiAoTlNNLmhhcyhkZWNvbXBvc2VkW2ldKSkge1xyXG5cdFx0XHRcdGxldCBqID0gaSArIDE7XHJcblx0XHRcdFx0Zm9yIChsZXQgY3A7IGogPCBlICYmIE5TTS5oYXMoY3AgPSBkZWNvbXBvc2VkW2pdKTsgaisrKSB7XHJcblx0XHRcdFx0XHQvLyBhLiBGb3JiaWQgc2VxdWVuY2VzIG9mIHRoZSBzYW1lIG5vbnNwYWNpbmcgbWFyay5cclxuXHRcdFx0XHRcdGZvciAobGV0IGsgPSBpOyBrIDwgajsgaysrKSB7IC8vIE8obl4yKSBidXQgbiA8IDEwMFxyXG5cdFx0XHRcdFx0XHRpZiAoZGVjb21wb3NlZFtrXSA9PSBjcCkge1xyXG5cdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihgbm9uLXNwYWNpbmcgbWFya3M6IHJlcGVhdGVkICR7cXVvdGVkX2NwKGNwKX1gKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHQvLyBwYXJzZSB0byBlbmQgc28gd2UgaGF2ZSBmdWxsIG5zbSBjb3VudFxyXG5cdFx0XHRcdC8vIGIuIEZvcmJpZCBzZXF1ZW5jZXMgb2YgbW9yZSB0aGFuIDQgbm9uc3BhY2luZyBtYXJrcyAoZ2M9TW4gb3IgZ2M9TWUpLlxyXG5cdFx0XHRcdGlmIChqIC0gaSA+IE5TTV9NQVgpIHtcclxuXHRcdFx0XHRcdC8vIG5vdGU6IHRoaXMgc2xpY2Ugc3RhcnRzIHdpdGggYSBiYXNlIGNoYXIgb3Igc3BhY2luZy1tYXJrIGNtXHJcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoYG5vbi1zcGFjaW5nIG1hcmtzOiB0b28gbWFueSAke2JpZGlfcXEoc2FmZV9zdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKSl9ICgke2otaX0vJHtOU01fTUFYfSlgKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aSA9IGo7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9XHJcblx0Ly8gKioqIHRoaXMgY29kZSBjdXJyZW50bHkgaXNuJ3QgbmVlZGVkICoqKlxyXG5cdC8qXHJcblx0bGV0IGNtX3doaXRlbGlzdCA9IE0gaW5zdGFuY2VvZiBNYXA7XHJcblx0Zm9yIChsZXQgaSA9IDAsIGUgPSBjcHMubGVuZ3RoOyBpIDwgZTsgKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbaSsrXTtcclxuXHRcdGxldCBzZXFzID0gY21fd2hpdGVsaXN0ICYmIE0uZ2V0KGNwKTtcclxuXHRcdGlmIChzZXFzKSB7IFxyXG5cdFx0XHQvLyBsaXN0IG9mIGNvZGVwb2ludHMgdGhhdCBjYW4gZm9sbG93XHJcblx0XHRcdC8vIGlmIHRoaXMgZXhpc3RzLCB0aGlzIHdpbGwgYWx3YXlzIGJlIDErXHJcblx0XHRcdGxldCBqID0gaTtcclxuXHRcdFx0d2hpbGUgKGogPCBlICYmIENNLmhhcyhjcHNbal0pKSBqKys7XHJcblx0XHRcdGxldCBjbXMgPSBjcHMuc2xpY2UoaSwgaik7XHJcblx0XHRcdGxldCBtYXRjaCA9IHNlcXMuZmluZChzZXEgPT4gIWNvbXBhcmVfYXJyYXlzKHNlcSwgY21zKSk7XHJcblx0XHRcdGlmICghbWF0Y2gpIHRocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjb21iaW5pbmcgbWFyayBzZXF1ZW5jZTogXCIke3NhZmVfc3RyX2Zyb21fY3BzKFtjcCwgLi4uY21zXSl9XCJgKTtcclxuXHRcdFx0aSA9IGo7XHJcblx0XHR9IGVsc2UgaWYgKCFWLmhhcyhjcCkpIHtcclxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudW5pY29kZS5vcmcvcmVwb3J0cy90cjM5LyNtaXhlZF9zY3JpcHRfY29uZnVzYWJsZXNcclxuXHRcdFx0bGV0IHF1b3RlZCA9IHF1b3RlZF9jcChjcCk7XHJcblx0XHRcdGZvciAobGV0IGNwIG9mIGNwcykge1xyXG5cdFx0XHRcdGxldCB1ID0gVU5JUVVFLmdldChjcCk7XHJcblx0XHRcdFx0aWYgKHUgJiYgdSAhPT0gZykge1xyXG5cdFx0XHRcdFx0Ly8gaWYgYm90aCBzY3JpcHRzIGFyZSByZXN0cmljdGVkIHRoaXMgZXJyb3IgaXMgY29uZnVzaW5nXHJcblx0XHRcdFx0XHQvLyBiZWNhdXNlIHdlIGRvbid0IGRpZmZlcmVudGlhdGUgUmVzdHJpY3RlZEEgZnJvbSBSZXN0cmljdGVkQiBcclxuXHRcdFx0XHRcdGlmICghdS5SKSBxdW90ZWQgPSBgJHtxdW90ZWR9IGlzICR7dS5OfWA7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKGBkaXNhbGxvd2VkICR7Zy5OfSBjaGFyYWN0ZXI6ICR7cXVvdGVkfWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgZGlzYWxsb3dlZCBjaGFyYWN0ZXI6ICR7cXVvdGVkfSAoZXhwZWN0ZWQgJHtnLk59KWApO1xyXG5cdFx0XHQvL3Rocm93IG5ldyBFcnJvcihgJHtnLk59IGRvZXMgbm90IGFsbG93OiAke3F1b3RlZH1gKTtcclxuXHRcdH1cclxuXHR9XHJcblx0aWYgKCFjbV93aGl0ZWxpc3QpIHtcclxuXHRcdGxldCBkZWNvbXBvc2VkID0gbmZkKGNwcyk7XHJcblx0XHRmb3IgKGxldCBpID0gMSwgZSA9IGRlY29tcG9zZWQubGVuZ3RoOyBpIDwgZTsgaSsrKSB7IC8vIHdlIGtub3cgaXQgY2FuJ3QgYmUgY20gbGVhZGluZ1xyXG5cdFx0XHRpZiAoQ00uaGFzKGRlY29tcG9zZWRbaV0pKSB7XHJcblx0XHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0XHR3aGlsZSAoaiA8IGUgJiYgQ00uaGFzKGRlY29tcG9zZWRbal0pKSBqKys7XHJcblx0XHRcdFx0aWYgKGogLSBpID4gTSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKGB0b28gbWFueSBjb21iaW5pbmcgbWFya3M6IFwiJHtzdHJfZnJvbV9jcHMoZGVjb21wb3NlZC5zbGljZShpLTEsIGopKX1cIiAoJHtqLWl9LyR7TX0pYCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGkgPSBqO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdCovXHJcbn1cclxuXHJcbi8vIGdpdmVuIGEgbGlzdCBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgYSBsaXN0IG9mIGxpc3RzLCB3aGVyZSBlbW9qaSBhcmUgYSBmdWxseS1xdWFsaWZpZWQgKGFzIEFycmF5IHN1YmNsYXNzKVxyXG4vLyBlZy4gZXhwbG9kZV9jcChcImFiY/CfkqlkXCIpID0+IFtbNjEsIDYyLCA2M10sIEVtb2ppWzFGNEE5LCBGRTBGXSwgWzY0XV1cclxuZnVuY3Rpb24gcHJvY2VzcyhpbnB1dCwgbmYpIHtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0bGV0IGNoYXJzID0gW107XHJcblx0aW5wdXQgPSBpbnB1dC5zbGljZSgpLnJldmVyc2UoKTsgLy8gZmxpcCBzbyB3ZSBjYW4gcG9wXHJcblx0d2hpbGUgKGlucHV0Lmxlbmd0aCkge1xyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCk7XHJcblx0XHRpZiAoZW1vamkpIHtcclxuXHRcdFx0aWYgKGNoYXJzLmxlbmd0aCkge1xyXG5cdFx0XHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0XHRcdFx0Y2hhcnMgPSBbXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXQucHVzaChlbW9qaSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsZXQgY3AgPSBpbnB1dC5wb3AoKTtcclxuXHRcdFx0aWYgKFZBTElELmhhcyhjcCkpIHtcclxuXHRcdFx0XHRjaGFycy5wdXNoKGNwKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRsZXQgY3BzID0gTUFQUEVELmdldChjcCk7XHJcblx0XHRcdFx0aWYgKGNwcykge1xyXG5cdFx0XHRcdFx0Y2hhcnMucHVzaCguLi5jcHMpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoIUlHTk9SRUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdFx0dGhyb3cgZXJyb3JfZGlzYWxsb3dlZChjcCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdGlmIChjaGFycy5sZW5ndGgpIHtcclxuXHRcdHJldC5wdXNoKG5mKGNoYXJzKSk7XHJcblx0fVxyXG5cdHJldHVybiByZXQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZpbHRlcl9mZTBmKGNwcykge1xyXG5cdHJldHVybiBjcHMuZmlsdGVyKGNwID0+IGNwICE9IEZFMEYpO1xyXG59XHJcblxyXG4vLyBnaXZlbiBhcnJheSBvZiBjb2RlcG9pbnRzXHJcbi8vIHJldHVybnMgdGhlIGxvbmdlc3QgdmFsaWQgZW1vamkgc2VxdWVuY2UgKG9yIHVuZGVmaW5lZCBpZiBubyBtYXRjaClcclxuLy8gKk1VVEFURVMqIHRoZSBzdXBwbGllZCBhcnJheVxyXG4vLyBhbGxvd3Mgb3B0aW9uYWwgRkUwRlxyXG4vLyBkaXNhbGxvd3MgaW50ZXJsZWF2ZWQgaWdub3JlZCBjaGFyYWN0ZXJzXHJcbi8vIGZpbGxzIChvcHRpb25hbCkgZWF0ZW4gYXJyYXkgd2l0aCBtYXRjaGVkIGNvZGVwb2ludHNcclxuZnVuY3Rpb24gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChjcHMsIGVhdGVuKSB7XHJcblx0bGV0IG5vZGUgPSBFTU9KSV9ST09UO1xyXG5cdGxldCBlbW9qaTtcclxuXHRsZXQgc2F2ZWQ7XHJcblx0bGV0IHN0YWNrID0gW107XHJcblx0bGV0IHBvcyA9IGNwcy5sZW5ndGg7XHJcblx0aWYgKGVhdGVuKSBlYXRlbi5sZW5ndGggPSAwOyAvLyBjbGVhciBpbnB1dCBidWZmZXIgKGlmIG5lZWRlZClcclxuXHR3aGlsZSAocG9zKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbLS1wb3NdO1xyXG5cdFx0bm9kZSA9IG5vZGUuQi5maW5kKHggPT4geC5RLmhhcyhjcCkpO1xyXG5cdFx0aWYgKCFub2RlKSBicmVhaztcclxuXHRcdGlmIChub2RlLlMpIHsgLy8gcmVtZW1iZXJcclxuXHRcdFx0c2F2ZWQgPSBjcDtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5DKSB7IC8vIGNoZWNrIGV4Y2x1c2lvblxyXG5cdFx0XHRpZiAoY3AgPT09IHNhdmVkKSBicmVhaztcclxuXHRcdH1cclxuXHRcdHN0YWNrLnB1c2goY3ApO1xyXG5cdFx0aWYgKG5vZGUuRikge1xyXG5cdFx0XHRzdGFjay5wdXNoKEZFMEYpO1xyXG5cdFx0XHRpZiAocG9zID4gMCAmJiBjcHNbcG9zIC0gMV0gPT0gRkUwRikgcG9zLS07IC8vIGNvbnN1bWUgb3B0aW9uYWwgRkUwRlxyXG5cdFx0fVxyXG5cdFx0aWYgKG5vZGUuVikgeyAvLyB0aGlzIGlzIGEgdmFsaWQgZW1vamkgKHNvIGZhcilcclxuXHRcdFx0ZW1vamkgPSBjb25mb3JtX2Vtb2ppX2NvcHkoc3RhY2ssIG5vZGUpO1xyXG5cdFx0XHRpZiAoZWF0ZW4pIGVhdGVuLnB1c2goLi4uY3BzLnNsaWNlKHBvcykucmV2ZXJzZSgpKTsgLy8gY29weSBpbnB1dCAoaWYgbmVlZGVkKVxyXG5cdFx0XHRjcHMubGVuZ3RoID0gcG9zOyAvLyB0cnVuY2F0ZVxyXG5cdFx0fVxyXG5cdH1cclxuXHQvKlxyXG5cdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHRpZiAoIWVtb2ppKSB7XHJcblx0XHRsZXQgY3AgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdGlmIChFTU9KSV9TT0xPLmhhcyhjcCkpIHtcclxuXHRcdFx0aWYgKGVhdGVuKSBlYXRlbi5wdXNoKGNwKTtcclxuXHRcdFx0ZW1vamkgPSBFbW9qaS5vZihjcCk7XHJcblx0XHRcdGNwcy5wb3AoKTtcclxuXHRcdH1cclxuXHR9XHJcblx0Ki9cclxuXHRyZXR1cm4gZW1vamk7XHJcbn1cclxuXHJcbi8vIGNyZWF0ZSBhIGNvcHkgYW5kIGZpeCBhbnkgdW5pY29kZSBxdWlya3NcclxuZnVuY3Rpb24gY29uZm9ybV9lbW9qaV9jb3B5KGNwcywgbm9kZSkge1xyXG5cdGxldCBjb3B5ID0gRW1vamkuZnJvbShjcHMpOyAvLyBjb3B5IHN0YWNrXHJcblx0aWYgKG5vZGUuViA9PSAyKSBjb3B5LnNwbGljZSgxLCAxKTsgLy8gZGVsZXRlIEZFMEYgYXQgcG9zaXRpb24gMSAoc2VlOiBtYWtlLmpzKVxyXG5cdHJldHVybiBjb3B5O1xyXG59XHJcblxyXG4vLyByZXR1cm4gYWxsIHN1cHBvcnRlZCBlbW9qaSBhcyBmdWxseS1xdWFsaWZpZWQgZW1vamkgXHJcbi8vIG9yZGVyZWQgYnkgbGVuZ3RoIHRoZW4gbGV4aWNvZ3JhcGhpYyBcclxuZnVuY3Rpb24gZW5zX2Vtb2ppKCkge1xyXG5cdC8vICoqKiB0aGlzIGNvZGUgY3VycmVudGx5IGlzbid0IG5lZWRlZCAqKipcclxuXHQvL2xldCByZXQgPSBbLi4uRU1PSklfU09MT10ubWFwKHggPT4gW3hdKTtcclxuXHRsZXQgcmV0ID0gW107XHJcblx0YnVpbGQoRU1PSklfUk9PVCwgW10pO1xyXG5cdHJldHVybiByZXQuc29ydChjb21wYXJlX2FycmF5cyk7XHJcblx0ZnVuY3Rpb24gYnVpbGQobm9kZSwgY3BzLCBzYXZlZCkge1xyXG5cdFx0aWYgKG5vZGUuUykgeyBcclxuXHRcdFx0c2F2ZWQgPSBjcHNbY3BzLmxlbmd0aC0xXTtcclxuXHRcdH0gZWxzZSBpZiAobm9kZS5DKSB7IFxyXG5cdFx0XHRpZiAoc2F2ZWQgPT09IGNwc1tjcHMubGVuZ3RoLTFdKSByZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZiAobm9kZS5GKSBjcHMucHVzaChGRTBGKTtcclxuXHRcdGlmIChub2RlLlYpIHJldC5wdXNoKGNvbmZvcm1fZW1vamlfY29weShjcHMsIG5vZGUpKTtcclxuXHRcdGZvciAobGV0IGJyIG9mIG5vZGUuQikge1xyXG5cdFx0XHRmb3IgKGxldCBjcCBvZiBici5RKSB7XHJcblx0XHRcdFx0YnVpbGQoYnIsIFsuLi5jcHMsIGNwXSwgc2F2ZWQpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuLy8gdG9rZW5pemVyIFxyXG5cclxuY29uc3QgVFlfVkFMSUQgPSAndmFsaWQnO1xyXG5jb25zdCBUWV9NQVBQRUQgPSAnbWFwcGVkJztcclxuY29uc3QgVFlfSUdOT1JFRCA9ICdpZ25vcmVkJztcclxuY29uc3QgVFlfRElTQUxMT1dFRCA9ICdkaXNhbGxvd2VkJztcclxuY29uc3QgVFlfRU1PSkkgPSAnZW1vamknO1xyXG5jb25zdCBUWV9ORkMgPSAnbmZjJztcclxuY29uc3QgVFlfU1RPUCA9ICdzdG9wJztcclxuXHJcbmZ1bmN0aW9uIGVuc190b2tlbml6ZShuYW1lLCB7XHJcblx0bmYgPSB0cnVlLCAvLyBjb2xsYXBzZSB1bm5vcm1hbGl6ZWQgcnVucyBpbnRvIGEgc2luZ2xlIHRva2VuXHJcbn0gPSB7fSkge1xyXG5cdGxldCBpbnB1dCA9IGV4cGxvZGVfY3AobmFtZSkucmV2ZXJzZSgpO1xyXG5cdGxldCBlYXRlbiA9IFtdO1xyXG5cdGxldCB0b2tlbnMgPSBbXTtcclxuXHR3aGlsZSAoaW5wdXQubGVuZ3RoKSB7XHRcdFxyXG5cdFx0bGV0IGVtb2ppID0gY29uc3VtZV9lbW9qaV9yZXZlcnNlZChpbnB1dCwgZWF0ZW4pO1xyXG5cdFx0aWYgKGVtb2ppKSB7XHJcblx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9FTU9KSSwgZW1vamksIGlucHV0OiBlYXRlbi5zbGljZSgpLCBjcHM6IGZpbHRlcl9mZTBmKGVtb2ppKX0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0bGV0IGNwID0gaW5wdXQucG9wKCk7XHJcblx0XHRcdGlmIChjcCA9PSBTVE9QKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX1NUT1AsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoVkFMSUQuaGFzKGNwKSkge1xyXG5cdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9WQUxJRCwgY3BzOiBbY3BdfSk7XHJcblx0XHRcdH0gZWxzZSBpZiAoSUdOT1JFRC5oYXMoY3ApKSB7XHJcblx0XHRcdFx0dG9rZW5zLnB1c2goe3R5cGU6IFRZX0lHTk9SRUQsIGNwfSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bGV0IGNwcyA9IE1BUFBFRC5nZXQoY3ApO1xyXG5cdFx0XHRcdGlmIChjcHMpIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9NQVBQRUQsIGNwLCBjcHM6IGNwcy5zbGljZSgpfSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHRva2Vucy5wdXNoKHt0eXBlOiBUWV9ESVNBTExPV0VELCBjcH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHRpZiAobmYpIHtcclxuXHRcdGZvciAobGV0IGkgPSAwLCBzdGFydCA9IC0xOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGxldCB0b2tlbiA9IHRva2Vuc1tpXTtcclxuXHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0b2tlbi50eXBlKSkge1xyXG5cdFx0XHRcdGlmIChyZXF1aXJlc19jaGVjayh0b2tlbi5jcHMpKSB7IC8vIG5vcm1hbGl6YXRpb24gbWlnaHQgYmUgbmVlZGVkXHJcblx0XHRcdFx0XHRsZXQgZW5kID0gaSArIDE7XHJcblx0XHRcdFx0XHRmb3IgKGxldCBwb3MgPSBlbmQ7IHBvcyA8IHRva2Vucy5sZW5ndGg7IHBvcysrKSB7IC8vIGZpbmQgYWRqYWNlbnQgdGV4dFxyXG5cdFx0XHRcdFx0XHRsZXQge3R5cGUsIGNwc30gPSB0b2tlbnNbcG9zXTtcclxuXHRcdFx0XHRcdFx0aWYgKGlzX3ZhbGlkX29yX21hcHBlZCh0eXBlKSkge1xyXG5cdFx0XHRcdFx0XHRcdGlmICghcmVxdWlyZXNfY2hlY2soY3BzKSkgYnJlYWs7XHJcblx0XHRcdFx0XHRcdFx0ZW5kID0gcG9zICsgMTtcclxuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh0eXBlICE9PSBUWV9JR05PUkVEKSB7IC8vIHx8IHR5cGUgIT09IFRZX0RJU0FMTE9XRUQpIHsgXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGlmIChzdGFydCA8IDApIHN0YXJ0ID0gaTtcclxuXHRcdFx0XHRcdGxldCBzbGljZSA9IHRva2Vucy5zbGljZShzdGFydCwgZW5kKTtcclxuXHRcdFx0XHRcdGxldCBjcHMwID0gc2xpY2UuZmxhdE1hcCh4ID0+IGlzX3ZhbGlkX29yX21hcHBlZCh4LnR5cGUpID8geC5jcHMgOiBbXSk7IC8vIHN0cmlwIGp1bmsgdG9rZW5zXHJcblx0XHRcdFx0XHRsZXQgY3BzID0gbmZjKGNwczApO1xyXG5cdFx0XHRcdFx0aWYgKGNvbXBhcmVfYXJyYXlzKGNwcywgY3BzMCkpIHsgLy8gYnVuZGxlIGludG8gYW4gbmZjIHRva2VuXHJcblx0XHRcdFx0XHRcdHRva2Vucy5zcGxpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0LCB7XHJcblx0XHRcdFx0XHRcdFx0dHlwZTogVFlfTkZDLCBcclxuXHRcdFx0XHRcdFx0XHRpbnB1dDogY3BzMCwgLy8gdGhlcmUgYXJlIDMgc3RhdGVzOiB0b2tlbnMwID09KHByb2Nlc3MpPT4gaW5wdXQgPT0obmZjKT0+IHRva2Vucy9jcHNcclxuXHRcdFx0XHRcdFx0XHRjcHMsIFxyXG5cdFx0XHRcdFx0XHRcdHRva2VuczA6IGNvbGxhcHNlX3ZhbGlkX3Rva2VucyhzbGljZSksXHJcblx0XHRcdFx0XHRcdFx0dG9rZW5zOiBlbnNfdG9rZW5pemUoc3RyX2Zyb21fY3BzKGNwcyksIHtuZjogZmFsc2V9KVxyXG5cdFx0XHRcdFx0XHR9KTtcclxuXHRcdFx0XHRcdFx0aSA9IHN0YXJ0O1xyXG5cdFx0XHRcdFx0fSBlbHNlIHsgXHJcblx0XHRcdFx0XHRcdGkgPSBlbmQgLSAxOyAvLyBza2lwIHRvIGVuZCBvZiBzbGljZVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c3RhcnQgPSAtMTsgLy8gcmVzZXRcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c3RhcnQgPSBpOyAvLyByZW1lbWJlciBsYXN0XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYgKHRva2VuLnR5cGUgIT09IFRZX0lHTk9SRUQpIHsgLy8gMjAyMjEwMjQ6IGlzIHRoaXMgY29ycmVjdD9cclxuXHRcdFx0XHRzdGFydCA9IC0xOyAvLyByZXNldFxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cdHJldHVybiBjb2xsYXBzZV92YWxpZF90b2tlbnModG9rZW5zKTtcclxufVxyXG5cclxuZnVuY3Rpb24gaXNfdmFsaWRfb3JfbWFwcGVkKHR5cGUpIHtcclxuXHRyZXR1cm4gdHlwZSA9PSBUWV9WQUxJRCB8fCB0eXBlID09IFRZX01BUFBFRDtcclxufVxyXG5cclxuZnVuY3Rpb24gcmVxdWlyZXNfY2hlY2soY3BzKSB7XHJcblx0cmV0dXJuIGNwcy5zb21lKGNwID0+IE5GQ19DSEVDSy5oYXMoY3ApKTtcclxufVxyXG5cclxuZnVuY3Rpb24gY29sbGFwc2VfdmFsaWRfdG9rZW5zKHRva2Vucykge1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRpZiAodG9rZW5zW2ldLnR5cGUgPT0gVFlfVkFMSUQpIHtcclxuXHRcdFx0bGV0IGogPSBpICsgMTtcclxuXHRcdFx0d2hpbGUgKGogPCB0b2tlbnMubGVuZ3RoICYmIHRva2Vuc1tqXS50eXBlID09IFRZX1ZBTElEKSBqKys7XHJcblx0XHRcdHRva2Vucy5zcGxpY2UoaSwgaiAtIGksIHt0eXBlOiBUWV9WQUxJRCwgY3BzOiB0b2tlbnMuc2xpY2UoaSwgaikuZmxhdE1hcCh4ID0+IHguY3BzKX0pO1xyXG5cdFx0fVxyXG5cdH1cclxuXHRyZXR1cm4gdG9rZW5zO1xyXG59XG5cbmV4cG9ydCB7IGVuc19iZWF1dGlmeSwgZW5zX2Vtb2ppLCBlbnNfbm9ybWFsaXplLCBlbnNfbm9ybWFsaXplX2ZyYWdtZW50LCBlbnNfc3BsaXQsIGVuc190b2tlbml6ZSwgaXNfY29tYmluaW5nX21hcmssIG5mYywgbmZkLCBzYWZlX3N0cl9mcm9tX2Nwcywgc2hvdWxkX2VzY2FwZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/@adraffy+ens-normalize@1.9.0/node_modules/@adraffy/ens-normalize/dist/index.js\n"));

/***/ }),

/***/ "../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/ens.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/ens.js ***!
  \*********************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getEnsAddress\": function() { return /* reexport safe */ _actions_ens_getEnsAddress_js__WEBPACK_IMPORTED_MODULE_1__.getEnsAddress; },\n/* harmony export */   \"getEnsAvatar\": function() { return /* reexport safe */ _actions_ens_getEnsAvatar_js__WEBPACK_IMPORTED_MODULE_2__.getEnsAvatar; },\n/* harmony export */   \"getEnsName\": function() { return /* reexport safe */ _actions_ens_getEnsName_js__WEBPACK_IMPORTED_MODULE_3__.getEnsName; },\n/* harmony export */   \"getEnsResolver\": function() { return /* reexport safe */ _actions_ens_getEnsResolver_js__WEBPACK_IMPORTED_MODULE_4__.getEnsResolver; },\n/* harmony export */   \"getEnsText\": function() { return /* reexport safe */ _actions_ens_getEnsText_js__WEBPACK_IMPORTED_MODULE_5__.getEnsText; },\n/* harmony export */   \"labelhash\": function() { return /* reexport safe */ _utils_ens_labelhash_js__WEBPACK_IMPORTED_MODULE_6__.labelhash; },\n/* harmony export */   \"namehash\": function() { return /* reexport safe */ _utils_ens_namehash_js__WEBPACK_IMPORTED_MODULE_7__.namehash; },\n/* harmony export */   \"normalize\": function() { return /* reexport safe */ _utils_ens_normalize_js__WEBPACK_IMPORTED_MODULE_0__.normalize; }\n/* harmony export */ });\n/* harmony import */ var _utils_ens_normalize_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utils/ens/normalize.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/utils/ens/normalize.js\");\n/* harmony import */ var _actions_ens_getEnsAddress_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions/ens/getEnsAddress.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/actions/ens/getEnsAddress.js\");\n/* harmony import */ var _actions_ens_getEnsAvatar_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions/ens/getEnsAvatar.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/actions/ens/getEnsAvatar.js\");\n/* harmony import */ var _actions_ens_getEnsName_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions/ens/getEnsName.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/actions/ens/getEnsName.js\");\n/* harmony import */ var _actions_ens_getEnsResolver_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions/ens/getEnsResolver.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/actions/ens/getEnsResolver.js\");\n/* harmony import */ var _actions_ens_getEnsText_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions/ens/getEnsText.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/actions/ens/getEnsText.js\");\n/* harmony import */ var _utils_ens_labelhash_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/ens/labelhash.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/utils/ens/labelhash.js\");\n/* harmony import */ var _utils_ens_namehash_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/ens/namehash.js */ \"../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/utils/ens/namehash.js\");\n\n\n\n\n\n\n\n\n//# sourceMappingURL=ens.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMS4wLjBfdHlwZXNjcmlwdEA1LjAuNF96b2RAMy4yMS40L25vZGVfbW9kdWxlcy92aWVtL2Rpc3QvZXNtL2Vucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXFEO0FBQ1c7QUFDRjtBQUNKO0FBQ1E7QUFDUjtBQUNMO0FBQ0Y7QUFDbkQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDEuMC4wX3R5cGVzY3JpcHRANS4wLjRfem9kQDMuMjEuNC9ub2RlX21vZHVsZXMvdmllbS9kaXN0L2VzbS9lbnMuanM/MTg5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgeyBub3JtYWxpemUgfSBmcm9tICcuL3V0aWxzL2Vucy9ub3JtYWxpemUuanMnO1xuZXhwb3J0IHsgZ2V0RW5zQWRkcmVzcywgfSBmcm9tICcuL2FjdGlvbnMvZW5zL2dldEVuc0FkZHJlc3MuanMnO1xuZXhwb3J0IHsgZ2V0RW5zQXZhdGFyLCB9IGZyb20gJy4vYWN0aW9ucy9lbnMvZ2V0RW5zQXZhdGFyLmpzJztcbmV4cG9ydCB7IGdldEVuc05hbWUsIH0gZnJvbSAnLi9hY3Rpb25zL2Vucy9nZXRFbnNOYW1lLmpzJztcbmV4cG9ydCB7IGdldEVuc1Jlc29sdmVyLCB9IGZyb20gJy4vYWN0aW9ucy9lbnMvZ2V0RW5zUmVzb2x2ZXIuanMnO1xuZXhwb3J0IHsgZ2V0RW5zVGV4dCwgfSBmcm9tICcuL2FjdGlvbnMvZW5zL2dldEVuc1RleHQuanMnO1xuZXhwb3J0IHsgbGFiZWxoYXNoIH0gZnJvbSAnLi91dGlscy9lbnMvbGFiZWxoYXNoLmpzJztcbmV4cG9ydCB7IG5hbWVoYXNoIH0gZnJvbSAnLi91dGlscy9lbnMvbmFtZWhhc2guanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZW5zLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/ens.js\n"));

/***/ }),

/***/ "../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/utils/ens/normalize.js":
/*!*************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/utils/ens/normalize.js ***!
  \*************************************************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"normalize\": function() { return /* binding */ normalize; }\n/* harmony export */ });\n/* harmony import */ var _adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @adraffy/ens-normalize */ \"../../node_modules/.pnpm/@adraffy+ens-normalize@1.9.0/node_modules/@adraffy/ens-normalize/dist/index.js\");\n\nfunction normalize(name) {\n    return (0,_adraffy_ens_normalize__WEBPACK_IMPORTED_MODULE_0__.ens_normalize)(name);\n}\n//# sourceMappingURL=normalize.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL3ZpZW1AMS4wLjBfdHlwZXNjcmlwdEA1LjAuNF96b2RAMy4yMS40L25vZGVfbW9kdWxlcy92aWVtL2Rpc3QvZXNtL3V0aWxzL2Vucy9ub3JtYWxpemUuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBdUQ7QUFDaEQ7QUFDUCxXQUFXLHFFQUFhO0FBQ3hCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4uLy4uL25vZGVfbW9kdWxlcy8ucG5wbS92aWVtQDEuMC4wX3R5cGVzY3JpcHRANS4wLjRfem9kQDMuMjEuNC9ub2RlX21vZHVsZXMvdmllbS9kaXN0L2VzbS91dGlscy9lbnMvbm9ybWFsaXplLmpzPzRjYTciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5zX25vcm1hbGl6ZSB9IGZyb20gJ0BhZHJhZmZ5L2Vucy1ub3JtYWxpemUnO1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZShuYW1lKSB7XG4gICAgcmV0dXJuIGVuc19ub3JtYWxpemUobmFtZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ub3JtYWxpemUuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///../../node_modules/.pnpm/viem@1.0.0_typescript@5.0.4_zod@3.21.4/node_modules/viem/dist/esm/utils/ens/normalize.js\n"));

/***/ })

}]);